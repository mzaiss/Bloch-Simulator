<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" /> <!-- needs to appear early -->
<!-- 
Bloch Simulator for educational interactive MR simulation.
Copyright (c) 2021 Lars G. Hanson, larsh#drcmr.dk, lghan#dtu.dk ( # -> @ )
http://drcmr.dk/larsh, http://www.cmr.healthtech.dtu.dk/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

Please do not redistribute versions yourself except via the channels below, but
instead share changes with the original developer to improve the official releases:
Online version: http://drcmr.dk/bloch
Software repository: https://github.com/larsh957/Bloch-Simulator
Android app: https://play.google.com/store/apps/developer?id=Lars+G.+Hanson

The software is buggy and tested fixes/improved are much appreciated if they impose 
no restrictions on software use or redistribution. Since the software development 
happens in spare time, bug reports and software suggestions may largely be ignored 
(ideas are already abundant, but time for implementation very limited).

-->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name='viewport' content='user-scalable=0' /> <!-- preventing non-canvas zoom -->
  <title>Bloch Simulator for MRI & NMR education</title>

  <script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.min.css"> 
  
  <!-- THREE.js and dat.gui via UMD builds for GitHub Pages compatibility -->
  <!-- Using r124 - last version with THREE.Geometry support -->
  <script src="https://unpkg.com/three@0.124.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/dat.gui@0.7.7/build/dat.gui.min.js"></script>
  
  <!-- Check https://learn.jquery.com/jquery-ui/getting-started/ for intro. -->
  <!-- jquery-mobile seems not worth the effort in this case. -->

<!-- Unused THREEx game extensions can likely add keyboard control, e.g (search THREEx further down).
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script> //Could possibly have saved some trouble.
-->

<!-- <link rel="manifest" href="manifest.json"> -->

</head>

<body style="overflow: hidden">

  <script>
    
    // Using global variables instead of ES6 imports for GitHub Pages compatibility
    // THREE, dat, and THREE.OrbitControls are loaded via script tags above
    
    "use strict"; // strict mode to avoid implicit globals added to global object "window".
    // Variables declared here are added to "window". Prefer variables local to app.
    
    // Check if dependencies loaded correctly
    if (typeof THREE === 'undefined') {
        console.error('THREE.js not loaded');
        alert('Error: THREE.js failed to load. Please check your internet connection.');
    }
    
    if (typeof dat === 'undefined') {
        console.error('dat.gui not loaded');
        alert('Error: dat.gui failed to load. Please check your internet connection.');
    }
    
    // WEBGL check - inline the WEBGL check since we can't import it as a module
    var WEBGL = {
        isWebGLAvailable: function () {
            try {
                var canvas = document.createElement( 'canvas' );
                return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );
            } catch ( e ) {
                return false;
            }
        },
        getWebGLErrorMessage: function () {
            return this.getErrorMessage( 1 );
        },
        getErrorMessage: function ( version ) {
            var names = {
                1: 'WebGL',
                2: 'WebGL 2'
            };
            var contexts = {
                1: window.WebGLRenderingContext,
                2: window.WebGL2RenderingContext
            };
            var message = 'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>';
            var element = document.createElement( 'div' );
            element.id = 'webglmessage';
            element.style.fontFamily = 'monospace';
            element.style.fontSize = '13px';
            element.style.fontWeight = 'normal';
            element.style.textAlign = 'center';
            element.style.background = '#fff';
            element.style.color = '#000';
            element.style.padding = '1.5em';
            element.style.width = '400px';
            element.style.margin = '5em auto 0';
            if ( contexts[ version ] ) {
                message = 'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">' + names[ version ] + '</a>';
            }
            element.innerHTML = message;
            return element;
        }
    };

    var camera, controls, renderer;
    var offsetHeight = 0;
    var zoomFactor = 1;
    var resizeTimeout;

    function adjustToScreen() {

	let scrHeight = window.innerHeight;
	let scrWidth = window.innerWidth;
	
	let shiftUp = false;

	var appFlag = document.URL.indexOf( 'http://' ) === -1 &&
	    document.URL.indexOf( 'https://' ) === -1; // Is code running as app?
	
//	let AndroidDevice = navigator.userAgent.includes('Android'); //not IE compat
	let AndroidDevice = (navigator.userAgent.indexOf('Android') != -1 ); 
	let iOSdevice = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	if ( AndroidDevice  || iOSdevice ) {
	    if ((scrWidth < 800) && (scrWidth < scrHeight)) {		
		$( "#dialogUseLandscape" ).dialog({
		    modal: false,
		    buttons: {
			Ok: function() {
			    $( this ).dialog( "close" );
			}}
		}).css("font-size", "35px");
		shiftUp = true; }
	    else { 
		$( "#dialogUseLandscape:visible" ).dialog( "close" ); 
		shiftUp = false;}
	    if (! appFlag) {
		$( "#dialogConsiderApp" ).dialog({
		    modal: false,
		    minWidth: 500,
		    buttons: {
			Ok: function() {
			    $( this ).dialog( "close" );
			}}
		}).css("font-size", "35px");
	    }	    
	}

	let totalWidth = 5; //5 is left margin
	$( '.EventButtons' ).each(function () { //doesnt work if $() is cached
	    offsetHeight || (offsetHeight = this.offsetHeight); //once!
	    $(this).css({
		left: totalWidth
	    });
	    totalWidth += this.offsetWidth + 10;
	});
	totalWidth -= 5; // Reduce right margin
	
	if ((scrWidth < 800) || (totalWidth > scrWidth))
	    zoomFactor = scrWidth / totalWidth;
	else
	    zoomFactor = 1;
	
	$( "#EventMenu").css('zoom', zoomFactor);
	
	$( '.EventButtons' ).css('z-index',20).each(function () {
	    $(this).css({
		top: scrHeight/zoomFactor - (1+shiftUp)*offsetHeight - 5
	    });
	});

	let iconWidth = $( ".icons" ).width();
	$( ".icons" ).css({
	    bottom: null,
	    right: null,
	    top: (scrHeight*0.65)+"px",
	    left: (scrWidth*0.97 - iconWidth - 2) + "px" //requires width to be set in HTML.
	});

	if (scrHeight < 600) {
	    $( "#Saving" ).hide();
	} else {
	    $( "#Saving" ).show();
	}

	//let socMediaWidth = $( "#socialMedia" ).width()); //too small.
	if (scrWidth > (800 + 180)) {
	    $( "#socialMedia" ).show()
	    if (scrWidth > (800 + 300))
		$( "#specificSocialMedia" ).show()
	    else
		$( "#specificSocialMedia" ).hide(); }
	else
	    $( "#socialMedia" ).hide();	
	
	camera.aspect = scrWidth / scrHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(scrWidth, scrHeight);

	if ($( "#newBlochSimulator" ).dialog( "instance" ) &&
	    $( "#newBlochSimulator" ).dialog( "isOpen" )) { //reopen to center.
		$( "#newBlochSimulator" ).dialog( "close" ).dialog( "open" );
	}
	
    } // adjustToScreen
    
    function onResize() {
// Throttle resizing. Ignore resize events as long as an adjustToScreen is queued.
	if ( !resizeTimeout ) {
	    resizeTimeout = setTimeout(function() {
		resizeTimeout = null;
		adjustToScreen();
		window.setTimeout(0); //flush cache;
		adjustToScreen(); // fire twice since fast width changes may cause small errors.
		// The adjustToScreen() will execute at a rate of max 5fps
	    }, 200);
	}
    } // onResize

    function dialog(id) {
	return function () {
	    $( "#"+id ).dialog({
		modal: false//,
		// buttons: {
		// 	Ok: function() {
		// 	    $( this ).dialog( "close" );
		// 	}}
		
	    }); }
    }
    
	
    function launchApp() { // started onload


	// Globals:  TODO: group them

	var debug = false;
	//
	// Set both reloadSceneResetsParms and hideWhenSelected false to provide two
	// levels of scene reload (minimal & full). Or latter true to save screen space:
	var reloadSceneResetsParms = false; // Scene main button does full reset.
	var hideWhenSelected = false; // Chosen scene label is removed from scene submenu.
	// Set Equilibrium menu item visible in HTML part if hideWhenSelected chosen false.
	//
	var scene;
	var eventButtons = $( '.EventButtons'); //cache for speed. 
	var gui, state, blochMenu;
	var dt, lastTime, elapsed, then;
	const fpsInterval = 1000/70; //set at 30 to keep more constant rate or free CPU.
	          // Will never be more than 60 (writing 70 makes it 60, if possible).
	const Tmax = 10; // maxmum finite relaxation time
	const B0max = 6;
	var savedState = {}; // used to save common parameters.
	var savedState2 = []; // used to save isochromate's parameters.
	var savedFlag = false; // is restoring of state an option?
	var paused = false;
	var guiFolderStrs = []; //stack of folder-names
	var guiFolders = [];    //stack of folders
	var addSampleFolder = false; //menu item for samples may confuse, so hidden.
	var nFolder = -1;
	var updateMenuList = [];
	var guiViewsFolder; // index of Fields menu item.
	var guiFieldsFolder; // index of Fields menu item.
	var guiGradientsFolder; // index of Gradient menu item.
	var guiFolderFlags = [true, true, true, true, true, true, true, true, true]; //folder closed?
	const guiUpdateInterval = 0.1; // seconds
	var guiTimeSinceUpdate = 0; 
	
	const nullvec = new THREE.Vector3(0., 0., 0.);
	const unitXvec = new THREE.Vector3(1., 0., 0.);
	const unitYvec = new THREE.Vector3(0., 1., 0.);
	const unitZvec = new THREE.Vector3(0., 0., 1.);
		
	var curveBlue = [], curveBlueTimes = [];
	var curveGreen = [], curveGreenTimes = [];
	var MxCurve = [], MxTimes = [];
	var MxyCurve = [], MxyTimes = [];
	var MzCurve = [], MzTimes =[];

	var MxLabelIdent = $( '#MxLabel');
	var MxyLabelIdent = $( '#MxyLabel');
	var MzLabelIdent = $( '#MzLabel');
	
	var FIDcanvas = document.getElementById("FIDcanvas");
	var FIDcanvasAxis = document.getElementById("FIDcanvasAxis");
	var FIDctx = FIDcanvas.getContext("2d");
	var FIDctxAxis = FIDcanvasAxis.getContext("2d");
	var grWidth = FIDcanvas.width;
	FIDcanvas.height = grWidth; // Needed to get aspect ratio of voxels right.
	FIDcanvasAxis.height = grWidth; // Apparantly canvas has two heights (clientheight)
	var grHeight = FIDcanvas.height;
	
	const FIDduration = 4000; //ms
	
	var trigSampleChange = false;
	var lastB1freq = 0;
	var dtTotal=0, dtCount=0;
	//	var dtMemory = Array(10).fill(0), dtMemIndi = 0; // not IE compat
	var dtMemory = [0,0,0,0,0,0,0,0,0,0], dtMemIndi = 0; 
	var spoilR2 = 0;

	var scenes = []; // Array of functions defining scenes.

	var floor, floorRect, floorCirc;
	var B1cyl, B1shadow;

	var frameFixed = false; //Frame is fixed when spatial axis is active.

	var framePhase = 0; //phase of rotating frame
	var framePhase0 = 0; //phase of rotating frame at start of RF pulse.
	
	var statsContainer, stats;
	const torqueScale = 0.5;
	const gradScale = 11;
	const B1scale = 0.4;
	const spoilDuration = 1000;
	var spoilTimer1, spoilTimer2, spoilTimer3;
	var restartRepIfSampleChange = false;
	var restartRepIfSampleChangeTimer;
	var exciteTimers = [];
	
	const white = new THREE.Color( 'white' );
	const greenStr = 'lawngreen';
	const green = new THREE.Color( greenStr ); //only this can be chosen freely.
	const red = new THREE.Color( 'red' );
	const blueStr = 'dodgerblue';
	const blue = new THREE.Color( blueStr );

	const nZeroSinc = 4; // 4 for 3-lobe sinc. Matching 0.22571 appears below.
	// A sinc with same B1 and duration as rect has durCorrSinc area ratio.
	// This is compensated by prolonging sinc pulse below. Wolfram knows Si(x).
	const durCorrSinc = 0.22571; // Si(2 pi)/(2 pi). Generally Si(nZ/2 pi) / (nZ/2 pi).
			
	const radius = 0.03; //cylinder radius
	const myShadow = true; // Shadows drawn manually.
	
	var shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x808070});
	var shadowMaterials = [];
	const downViewThresh = Math.PI/4; // shadow decreases below 45 degree polar.
	
	// Semi-transparant test:
	//      var shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true,  opacity: 0.5, blending: THREE.NormalBlending});
	
	var torqueMaterial = new THREE.MeshLambertMaterial({ color: 0xc80076 });
	var B1effMaterial = new THREE.MeshLambertMaterial({ color: "blue" });
	var floorMaterial = new THREE.MeshLambertMaterial({ color: 0xb0b090 }); //s:0x808070
	//	var floorMaterialFixed = new THREE.MeshLambertMaterial({ color: 0x90b0a0 });
	var floorMaterialFixed = new THREE.MeshLambertMaterial({ color: 0x90b0d0 });
	var floorMaterialBlack = new THREE.MeshLambertMaterial({ color: 0x303030 }); 
	const nShadowColors = 16;
	
	var doStats = false; // framerate statistics
	var addAxisHelper = false;
	var threeShadow = false; // Let Three.js handle shadows.

	// x-rotation 90 for testing:
	var propagator90x = new THREE.Matrix4().set(
	    1, 0, 0, 0,
	    0, Math.cos(Math.PI/2), Math.sin(Math.PI/2), 0,
	    0, -Math.sin(Math.PI/2), Math.cos(Math.PI/2), 0,
	    0, 0, 0, 1);
	
	var propagator90y = new THREE.Matrix4().set(
	    Math.cos(Math.PI/2), 0, Math.sin(Math.PI/2), 0,
	    0, 1, 0, 0,
	    -Math.sin(Math.PI/2), 0, Math.cos(Math.PI/2), 0,
	    0, 0, 0, 1);
	
	function cylinderMesh(fromVec, toVec, material, nElem, radius) {
	    var vec = toVec.clone().sub(fromVec);
	    var h = vec.length();
	    vec.divideScalar(h || 1);
	    var quaternion = new THREE.Quaternion();
	    quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec);
	    var geometry = new THREE.CylinderBufferGeometry(radius, radius, h, nElem);
	    // BufferGeometries (eg. CylinderBufferGeometry) are faster
	    // than Geometries and require less memory. See
	    // https://threejsfundamentals.org/threejs/lessons/threejs-custom-buffergeometry.html
	    geometry.translate(0, h/2, 0);
	    var cylinder = new THREE.Mesh(geometry, material);
	    cylinder.applyQuaternion(quaternion);
	    cylinder.position.set(fromVec.x, fromVec.y, fromVec.z);
	    return cylinder;
	} //cylinderMesh

	function shadowMesh(Mvec) {
	    var MvecTrans = new THREE.Vector2(Mvec.x, Mvec.y);
	    var MvecTransLength = MvecTrans.length();
	    
	    var direction = Mvec.clone().projectOnPlane(unitZvec);

	    var orientation = new THREE.Matrix4();
	    orientation.lookAt(nullvec, Mvec.projectOnPlane(unitZvec), new THREE.Object3D().up);
	    orientation.multiply(new THREE.Matrix4().set( 1,  0,  0,  0,
							  0,  0,  1,  0,
							  0, -1,  0,  0,
							  0,  0,  0,  1));
	    
	    var shadowBarGeo = new THREE.PlaneGeometry(2*radius, MvecTransLength);	      
	    shadowBarGeo.translate( 0, MvecTransLength/2, -1.1);
	    var shadowBarMesh = new THREE.Mesh(shadowBarGeo);
	    
	    var shadowEndGeo = new THREE.CircleGeometry(radius, 4, 0, Math.PI); //only dot at far end.
	    shadowEndGeo.translate( 0, MvecTransLength, -1.1);
	    var shadowEndMesh = new THREE.Mesh(shadowEndGeo);	      
	    shadowEndMesh.rotation.z = MvecTrans.angle()+Math.PI/2;
	    
	    var shadowGeo = new THREE.Geometry();  //merged BufferGeometry shadows fail to render with no
	    // messages issued. Added Buffer here and above. https://stackoverflow.com/questions/36450612
	    shadowGeo.merge(shadowBarMesh.geometry, shadowBarMesh.matrix);
	    shadowGeo.merge(shadowEndMesh.geometry, shadowEndMesh.matrix);
	    var mesh = new THREE.Mesh(shadowGeo, shadowMaterial);
	    
	    mesh.applyMatrix4(orientation);
	    
	    return mesh;
	} //shadowMesh
	

	function Isoc(M, color, pos, nElem, showCurve, dR1, dR2, M0, dRadius) {  //isocromate constructor
	    this.M = M.clone();
	    this.dB0 = 0; //spatially independent field offset
	    this.detuning = 0; // total field offset from RF freq
	    this.dMRF = new THREE.Vector3(0, 0, 1);
	    this.color = color; // don't clone since color-pointer is used as identifier.
	    this.pos = pos.clone();
	    this.showCurve = showCurve;
	    this.dR1 = dR1;
	    this.dR2 = dR2;
	    this.M0 = (M0 >= 0) ? M0 : 1;
	    this.dRadius = dRadius?dRadius: 0;
		
	    nElem || (nElem = 8); // controls cylinder surface smoothness.TODO: reduce for small screen.
	    var cylMaterial = new THREE.MeshLambertMaterial({ color: color });
	    this.cylMesh = cylinderMesh(new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(0, 1, 0),
					cylMaterial, nElem, radius + this.dRadius);
	    scene.add(this.cylMesh);
	    this.torque = cylinderMesh(new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(0, 1, 0),
				       torqueMaterial, nElem, radius + this.dRadius);
	    scene.add(this.torque);
	    this.B1eff = cylinderMesh(new THREE.Vector3(0, 0, 0),
				      new THREE.Vector3(0, 1, 0),
				      B1effMaterial, nElem, 1.01*(radius + this.dRadius));
	    scene.add(this.B1eff);
	    
	    if (myShadow) {
		// Shadows are initialized along y to make length right subsequently.
		this.shadow = shadowMesh(new THREE.Vector3(0, 1, 0));
		scene.add(this.shadow);
		this.tshadow = shadowMesh(new THREE.Vector3(0, 1, 0));
		scene.add(this.tshadow);
	    }
	} //Isoc

	// Use prototype to avoid copies for each instance.
	// Likely more manipulation should be in prototype.
	// https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b

	Isoc.prototype.scale = function (scalar) {  //adds method "scale" to Isoc prototype.
	    this.M = this.M.multiplyScalar(scalar);
	    this.dMRF = this.dMRF.multiplyScalar(scalar);
	    return this;
	}

	
	Isoc.prototype.remove = function () {
	    scene.remove(this.cylMesh);
	    scene.remove(this.torque);
	    scene.remove(this.B1eff);
	    if (myShadow) {
		scene.remove(this.shadow);
		scene.remove(this.tshadow);
	    }
	}

	function scaleIsocArr(isocArr, factor) {
	    isocArr.forEach(function (item, index) {item.scale(factor)});
	    return isocArr;
	}

	function removeIsocArr() {
	    state.IsocArr.forEach(function (item, index) {item.remove()});
	}

	
	function guiAddFolder(StrClosed,StrOpen,AdderFct,cFolder,createFromFolder) {
	    if (createFromFolder <= 0) { // does nothing unless index to start creating from is zero (or less)
		let folderLabel = guiFolderFlags[cFolder]?StrClosed:StrOpen;
		guiFolderStrs.push(folderLabel);
		let guiFolder = gui.addFolder(folderLabel);
		guiFolders.push(guiFolder);
		AdderFct(guiFolder);
		if (createFromFolder < 0) {
		    guiFolderFlags[cFolder]=true; }
		if (guiFolderFlags[cFolder]) {
		    guiFolder.close();
		    // last folder's state of openess decides viewing order of stacked elems:
		    if (cFolder == nFolder)  //reset depth to normal if last folder is closed.
			eventButtons.css('z-index',20); 
		}
		else {
		    guiFolder.open();
		    if (cFolder == nFolder-1) //lower buttons if last folder is open.
			eventButtons.css('z-index',0); // for small displays.
		}
		return guiFolder;
	    }
	} //guiAddFolder
	
	function guiCloseFolder (guiFolder) {
	    // possibly useful for Help dat-gui-item that does not need label updating.
	    guiFolder.close();
	    guiFolderFlags[ guiFolders.indexOf(guiFolder) ] = true;
	} //guiCloseFolder
	

	function scaleMultiple(magVecs, scalar){
	    for(let i = 0; i < magVecs.length; i++) 
		magVecs[i].scale(scalar);
	}


	function RFconst(B1, B1freq) {
	    let phase = B1freq * state.tSinceRF - state.phi1 + framePhase0;
	    return [new THREE.Vector3(B1*Math.cos(phase), -B1*Math.sin(phase), 0.), B1];
	}

	function RFsincWrapper (duration) { //wrapper needed to avoid recalc of duration.
	    return function RFsinc(B1, B1freq) {
		let phase = B1freq * state.tSinceRF - state.phi1 + framePhase0;
		let sincArg = nZeroSinc * Math.PI * (state.tSinceRF/duration-1/2);
		let envelope = (Math.abs(sincArg) > 0.01) ?
		    (B1*Math.sin(sincArg)/sincArg) : B1;
		return [new THREE.Vector3(envelope*Math.cos(phase),
					  -envelope*Math.sin(phase), 0.),
			envelope];
	    }
	}
	
	function RFpulse(type, angle, phase, B1) {	    
	    let gamma = state.Gamma;
	    state.tSinceRF = 0; // Both area and time left is needed for pulse with
	    state.areaLeftRF = angle; // sidelobes. Area is adjusted at temporal end.
	    let duration = angle / (gamma*B1);
	    state.B1 = B1;
	    state.B1freq = gamma * state.B0;
	    var dtAvg = dtMemory.reduce( function (a,b) {return a + b}, 0) / dtMemory.length;  //short function notation is not IE compatible.
	    phase += state.B1freq * gamma * dtAvg/2; //small phase correction
	    framePhase0 = framePhase;
	    state.phi1 = phase; 
	    switch (type) {
	    case 'rect': state.RFfunc = RFconst; break;
	    case 'sinc': duration = duration / durCorrSinc;
		state.RFfunc = RFsincWrapper(duration); break;
	    default: alert('Unknown RF pulse type');
	    }
	    state.tLeftRF = duration; 
	    updateMenuList.push(guiFieldsFolder); //mark field folder for updating
	}  //RFpulse

	function spoil() {
	    spoilR2 = 4.7;
	    window.setTimeout(
		function () {		
		    spoilR2 = 0;
		    if (state.Sample == "Thermal ensemble") return; //dont spoil thermal.
		    for (var i = 0; i < state.IsocArr.length; i++) { //kill any remaining Mxy.
			state.IsocArr[i].M.projectOnVector(unitZvec);}}, 
		spoilDuration); //ms
	} //spoil

	function gradPulse(phaseDiff, directionAngle) {
	    const gradDur = 1; //s
	    state.areaLeftGrad = phaseDiff*gradScale/state.Gamma;
	    if (directionAngle) {
		state.Gx = Math.cos(directionAngle) * state.areaLeftGrad/gradDur;
		state.Gy = Math.sin(directionAngle) * state.areaLeftGrad/gradDur;
	    } else { //default is Gx
		state.Gx = state.areaLeftGrad/gradDur;
		directionAngle = 0;
	    }
	    state.PulseGradDirection = directionAngle;
	    updateMenuList.push(guiGradientsFolder);
	} // gradPulse

	function gradRefocus() {
	    let isocArr = state.IsocArr;
	    let meanPhaseDiff = 0;
	    let MxyLeft, MxyRight;
	    let dx,weight;
	    let totalWeight = 0;
	    let phaseRight; // Right isocs phase
	    let phaseDiff; //phase difference
	    MxyLeft = isocArr[0].M.clone().projectOnPlane(unitZvec);
	    for(let i = 1; i <= isocArr.length-2; i++) {
		dx = isocArr[i].pos.x - isocArr[i-1].pos.x;
		if (dx > 0) { // ignore lineshifts in plane
		    MxyRight = isocArr[i].M.clone().projectOnPlane(unitZvec);
		    weight = Math.min(MxyLeft.length(), MxyRight.length());
		    totalWeight += weight;
		    phaseRight = Math.atan2(MxyRight.y, MxyRight.x);
		    MxyLeft.applyAxisAngle(unitZvec,-phaseRight); //rotate left isoc by right's angle.
		    phaseDiff = Math.atan2(MxyLeft.y, MxyLeft.x);
		    meanPhaseDiff += weight * phaseDiff / dx;
		    MxyLeft = MxyRight; // right is the new left
		}
	    }
	    if ((Math.abs(meanPhaseDiff)>0.001) && (totalWeight>0.01)) {
		meanPhaseDiff = meanPhaseDiff/totalWeight;
		gradPulse(-meanPhaseDiff);
	    }
	} // gradRefocus


	function thermalDrawFromLinearDist(B0) { //draws sample from -1 to 1
	    const pol = B0/B0max; // 0 to 1. Zero gives uniform distribution.
	    var sample;
	    
	    let random = Math.random();
	    if (random > pol) //sample from uniform dist, if random is gt pol-treshold.
		sample = 2*Math.random()-1
	    else
		sample = 2*Math.sqrt(Math.random())-1; //linear dist
	    return sample;
	}

	function magInit() {
	    const c10 = Math.cos(10*Math.PI/180);
	    const s10 = Math.sin(10*Math.PI/180);
	    const c30 = Math.cos(30*Math.PI/180);
	    const s30 = Math.sin(30*Math.PI/180);
	    const eps = 0.05;
	    const xz30 = new THREE.Vector3(s30, 0, c30);
	    const x = new THREE.Vector3(1, 0, 0);
	    const y = new THREE.Vector3(0, 1, 0);
	    const z = new THREE.Vector3(0, 0, 1);
	    const nx = new THREE.Vector3(-1, 0, 0);
	    const ny = new THREE.Vector3(0, -1, 0);
	    const nz = new THREE.Vector3(0, 0, -1);
	    const xyz = new THREE.Vector3(1 + eps, 1 - eps, 1);
	    const xynz = new THREE.Vector3(1, 1, -1);
	    const xnyz = new THREE.Vector3(1 + eps, -1 + eps, 1);
	    const nxyz = new THREE.Vector3(-1 - eps, 1 - eps, 1);
	    const nxnyz = new THREE.Vector3(-1 - eps, -1 + eps, 1);
	    const xnynz = new THREE.Vector3(1, -1, -1);
	    const nxynz = new THREE.Vector3(-1, 1, -1);
	    const nxnynz = new THREE.Vector3(-1, -1, -1);
	    
	    function IsocXz30() {return new Isoc(xz30, // M
						 white, // color
						 nullvec); }  // pos
	    function IsocX() { return new Isoc(x, white, nullvec); }
	    function IsocY() { return new Isoc(y, white, nullvec); }
	    function IsocZ() { return new Isoc(z, white, nullvec); }
	    function IsocZensembleRed() { return new Isoc(z, red, nullvec); }
	    let nElem = 8; //controls cylinder surface smoothness.
	    function IsocZgreen() { let M0 = 0.91;
				    return new Isoc(
					new THREE.Vector3(0, 0, M0),
					green, nullvec, nElem, // Note: added relax dR1, dR2 must be pos.
					true, 0, 0, M0, 0); } //showCurve, dR1, dR2, M0, dRadius
	    function IsocZblue() { let M0 = 1.0;
				    return new Isoc(
					new THREE.Vector3(0, 0, M0),
					blue, nullvec, nElem,
					true, 0.2, 0.2, M0, 0.001); } //showCurve, dR1, dR2, M0, dRadius
	    
	    function IsocZwhite() {let M0 = 0.91;
				  return new Isoc(
				      new THREE.Vector3(0, 0, M0), 
				      white, nullvec, nElem,
				      true, 0, 0.2, M0, 0.0008); } //showCurve, dR1, dR2, M0, dRadius
	    function IsocNX() { return new Isoc(nx, white, nullvec); }
	    function IsocNY() { return new Isoc(ny, white, nullvec); }
	    function IsocNZ() { return new Isoc(nz, white, nullvec); }
	    function IsocXYZ() { return new Isoc(xyz, white, nullvec); }
	    function IsocXYNZ() { return new Isoc(xynz, white, nullvec); }
	    function IsocXNYZ() { return new Isoc(xnyz, white, nullvec); }
	    function IsocNXYZ() { return new Isoc(nxyz, white, nullvec); }
	    function IsocNXNYZ() { return new Isoc(nxnyz, white, nullvec); }
	    function IsocXNYNZ() { return new Isoc(xnynz, white, nullvec); }
	    function IsocNXYNZ() { return new Isoc(nxynz, white, nullvec); }
	    function IsocNXNYNZ() { return new Isoc(nxnynz, white, nullvec); }

	    let basicState= {IsocArr:[], B1:0.0, Gamma:1, 
			     B0:2.,
//			     t:0, //removed to avoid resetting of FID. Seems ok.
			     dt:0.01, phi1:0., T1:Infinity, T2:Infinity, B1freq: 5,
			     Name:'', RFfunc:RFconst};
	    
	    scenes.Isoc1 = function () {
		return {IsocArr:[IsocZ()]}};

	    scenes.Precession = function () {
		Object.assign(state, basicState);
		return {IsocArr:[IsocXz30()]}};
	    
	    scenes.Equilibrium = function ()  
	    { Object.assign(state, basicState);
	      return {IsocArr:[IsocZ()], 
		      T1: Infinity, T2: Infinity,
		      RFfunc:RFconst,
		      viewMx:true}; }
	
	    scenes.IsocInhomN = function (nIsoc) {
		let inhom = {IsocArr:[]};
		const spreadScale = 1/6; 
		const nonlinScale = Math.PI/1.5; //reduces recovery
		for(let i=0; i<nIsoc; i++) {
		    inhom.IsocArr.push(IsocZ());
		    inhom.IsocArr[i].dB0 =
			Math.tan( (i-(nIsoc-1)/2) / (nIsoc/nonlinScale) ) * spreadScale;
		}
		return inhom;
	    } //IsocInhomN
	    
	    scenes.Inhomogeneity = function () {
		Object.assign(state, basicState);
		Object.assign(state, scenes.IsocInhomN(9));
		return {};
	    }
	    
	    
	    scenes.ThermalEnsemble = function () {
		// Creates pseudo random state that appears more random than random.
		// For each cosTheta, 3+-k*B0 isocs evenly rotated over cirle are added.
		let B0 = B0max;
		const nBand = 100; //select even
		const perBand = 3;
		var Isocs = [];
		var cosTheta;
		let M = new THREE.Vector3;
		for(let i=0; i < nBand; i++) {
		    cosTheta = i - nBand/2 + 0.5; //symmetric and avoid extremes
		    cosTheta = cosTheta / (nBand/2); // -1 < cosTheta < 1
		    let phi = Math.random() * 2 * Math.PI;
		    let perBandAdjusted = Math.round((1+cosTheta*(B0/B0max))*perBand);
		    for (let j=0; j < perBandAdjusted ; j++) {
			M.z = cosTheta;
			let Mxy = Math.sqrt(1 - M.z * M.z);
			let arg = phi + (2*Math.PI) * (j + Math.random()/2) / perBandAdjusted;
			M.x = Mxy * Math.cos(arg);
			M.y = Mxy * Math.sin(arg);
			Isocs.push( new Isoc(M, white, nullvec) );
		    }
		}
		return {IsocArr:Isocs, viewMz:true, // B0:B0, (left low for better viz)
			FrameStat:false, FrameB0:true, FrameB1:false};
	    } //ThermalEnsemble
	    
	    scenes.ThermalEnsembleSimple = function () { // NOT used currently.
		// simplified view. Fails when relaxation is added.
		let axisVecs = [IsocZensembleRed().scale(1.03), IsocNZ().scale(0.97),
				IsocX(), IsocY(), IsocNX(), IsocNY()];
		axisVecs[0].color = red; 
	    	let diagVecs = [IsocXYZ(), IsocNXYZ(), IsocXNYZ(), IsocXYNZ(), 
				IsocNXNYZ(), IsocNXYNZ(), IsocXNYNZ(), IsocNXNYNZ()];
	    	diagVecs = scaleIsocArr(diagVecs, 1/Math.sqrt(3));
	    	return {IsocArr: axisVecs.concat(diagVecs) };
		
	    } //ThermalEnsembleSimple

	    
	    scenes.Ensemble = function () {
		Object.assign(state, basicState);
		return scenes.ThermalEnsemble();
	    }

	    scenes.Substances3 = function () {
		let isocs = {IsocArr: [IsocZblue(), IsocZgreen(), IsocZwhite()]};
		isocs.IsocArr[0].dB0 = 0;
		isocs.IsocArr[1].dB0 = -0.04;
		isocs.IsocArr[2].dB0 = 0.04;
		return isocs;
	    }
	    
	    scenes.MixedMatter = function () {
		Object.assign(state, basicState);
		state.T1 = 8;
		state.T2 = 5;
		Object.assign(state, scenes.Substances3());
		return {viewMx: false, viewMxy: true};
	    }

	    scenes.Line = function () {
		const nIsoc = 21; // choose odd number of isochromates.
		var line = [];
		for(let i=0; i<nIsoc; i++) {
		    line.push(IsocZ());
		    line[i].pos.setX((i-(nIsoc-1)/2)*0.4);
		}
		return {IsocArr: line, allScale: 0.35, Gx: 3};
	    }
	    
	    // scenes.LineDense = function () {
	    // 	const nIsoc = 41; // choose odd number of isochromates.
	    // 	var line = [];
	    // 	for(let i=0; i<nIsoc; i++) {
	    // 	    line.push(IsocZ());
	    // 	    line[i].pos.setX((i-(nIsoc-1)/2)*0.2);
	    // 	}
	    // 	return {IsocArr: line, allScale: 0.35};
	    // }

	    scenes.LineDense = function (uniform) {
		const nIsoc = 41; // Not all are realized for structured object.
		var line = [];
		var shift = 1;
		for(let i=0; i<nIsoc; i++) {
		    if (uniform || ((Math.floor((i-shift)/3) % 2) == 0)) {
			let isoc = IsocZ();
			isoc.pos.setX((i-(nIsoc-1)/2)*0.2);
			line.push(isoc);
		    }
		}
		return {IsocArr: line, allScale: 0.35, Gx: -6};
	    }

	    scenes.Plane = function () {
		const nIsoc = 21; // choose odd number of isochromates.
		var plane = [];
		for(let i=0; i<nIsoc; i++) {
		    for(let j=0; j<nIsoc; j++) {
			plane.push(IsocZ());
			plane[i*nIsoc+j].pos.set((j-(nIsoc-1)/2)*0.4,(i-(nIsoc-1)/2)*0.4,0);
		    }
		}
		return {IsocArr: plane, allScale: 0.35};
	    }
	    
	    scenes.WeakGradient = function () {
		Object.assign(state, basicState);
		Object.assign(state, scenes.Line());
		return {B1freq: 3};
	    }

	    scenes.StrongGradient = function (uniform) {
		Object.assign(state, basicState);
		Object.assign(state, scenes.LineDense(uniform));
		return {B1freq: 0, FrameB0:true, FrameB1:false, FrameStat:false};
	    }

	    
	} //magInit

	function initFIDctxAxis() {
	    FIDctxAxis.clearRect(0, 0, grWidth, grHeight);
	    FIDctxAxis.save();
	    FIDctxAxis.strokeStyle = 'gray';
	    FIDctxAxis.fillStyle = 'gray';
	    FIDctxAxis.lineWidth = 1;
	    let offset = 4; //half triangle size
	    FIDctx.translate(offset, grHeight/2);
	    FIDctx.scale(0.95,0.95);
	    FIDctx.translate(offset, -grHeight/2);
	    FIDctxAxis.beginPath();
	    FIDctxAxis.moveTo(offset, 0); //vertical axis:
	    FIDctxAxis.lineTo(offset, grHeight);
	    let nTick = 8; // tick marks:
	    for(let cTick=1; cTick<nTick; cTick++) { 
		FIDctxAxis.moveTo(-offset, grHeight*cTick/nTick);
		FIDctxAxis.lineTo(offset, grHeight*cTick/nTick);
	    }
	    FIDctxAxis.stroke();
	    FIDctxAxis.beginPath(); // triangle:
	    FIDctxAxis.moveTo(offset, 0);
	    FIDctxAxis.lineTo(0, 2*offset); 
	    FIDctxAxis.lineTo(2*offset, 2*offset);
	    FIDctxAxis.fill();	    
	    FIDctxAxis.beginPath();
	    FIDctxAxis.moveTo(offset, grHeight/2); //horizontal axis:
	    FIDctxAxis.lineTo(grWidth, grHeight/2);
	    FIDctxAxis.stroke();
	    FIDctxAxis.beginPath(); // triangle:
	    FIDctxAxis.moveTo(grWidth-2*offset, grHeight/2-offset); 
	    FIDctxAxis.lineTo(grWidth, grHeight/2);
	    FIDctxAxis.lineTo(grWidth-6, grHeight/2+offset);
	    FIDctxAxis.fill();
	    FIDctxAxis.restore();
	} //initFIDctxAxis
	

	function sampleChange() {

	    if (paused) {
		paused = false;
		$( "#Pause" ).button( "option", "label", "||");
	    }

	    trigSampleChange = false;  //clear request for further updating.
	    removeIsocArr();
	    state.allScale = 1; //default
	    state.curveScale = 1; //default
	    switch (state.Sample) {
	    case 'Precession': /* Scene-changes from here: */
		state = Object.assign(state, scenes.Precession());
		state.Sample = '1 isochromate';
		frameFixed = false; //TODO: Why is frameFixed not in scenes-definitions?
		$("#Presets").css('color', '#bbbbbb'); break; 
	    case 'Equilibrium':
		state = Object.assign(state, scenes.Equilibrium());
		state.Sample = '1 isochromate';
		frameFixed = false;
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Inhomogeneity':
		state = Object.assign(state, scenes.Inhomogeneity());
		state.Sample = '9 isochromates';
		frameFixed = false;
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Ensemble':
		state = Object.assign(state, scenes.Ensemble());
		state.Sample = 'Thermal ensemble';
		state.curveScale = 2;
		frameFixed = false;
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Weak gradient':
		state = Object.assign(state, scenes.WeakGradient());
		frameFixed = true;
		state.Sample = 'Line';
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Strong gradient':
		state = Object.assign(state, scenes.StrongGradient(true));
		frameFixed = true;
		state.Sample = 'Line, dense';
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Structure':
		state = Object.assign(state, scenes.StrongGradient(false));
		frameFixed = true;
		state.Sample = 'Line, structured';
		$("#Presets").css('color', '#ffffff'); break;
	    case 'Mixed matter':
		state = Object.assign(state, scenes.MixedMatter());
		state.Sample = '3 substances';
		frameFixed = false;
		$("#Presets").css('color', '#ffffff');  break; /* Sample-changes from here: */
	    case '1 isochromate': 
		state = Object.assign(state, scenes.Isoc1());
		frameFixed = false; break;
	    case '9 isochromates':
		state = Object.assign(state, scenes.IsocInhomN(9));
		frameFixed = false; break;
	    case '3 substances':
		state = Object.assign(state, scenes.Substances3());
		frameFixed = false; break;
	    case 'Thermal ensemble':
		state = Object.assign(state, scenes.ThermalEnsemble());
		frameFixed = false; break;		
	    case 'Line':
		state = Object.assign(state, scenes.Line());
		frameFixed = true; break;				   
	    case 'Line, dense':
		state = Object.assign(state, scenes.LineDense(true));
		frameFixed = true; break; 
	    case 'Line, structured':
		state = Object.assign(state, scenes.LineDense(false));
		frameFixed = true; break;
	    case 'Plane':
		state = Object.assign(state, scenes.Plane());
		frameFixed = true; break;				   
	    default: alert("Sample changed to "+state.Sample);
	    }

	    
	    if (restartRepIfSampleChange) { // Re-excite is relevant for multi-SE.
		clearRepTimers();
		restartRepIfSampleChangeTimer = window.setTimeout(		    
		    function() {
			let elem = document.getElementById('RepExc');
			let label = elem.textContent || elem.innerText || "";
			buttonAction(label);
		    }
		    , 4000);
	    }
	    
	    if (frameFixed && (! state.FrameStat)) 
		floor.material = floorMaterialFixed;
	    else 
		floor.material = floorMaterial;
	    shadowMaterialsInit(floor.material);

	    // Update FID label visibility:
	    state.viewMx ? MxLabelIdent.show() : MxLabelIdent.hide();
	    state.viewMz ? MzLabelIdent.show() : MzLabelIdent.hide();
	    state.viewMxy ? MxyLabelIdent.show() : MxyLabelIdent.hide();
	    curveBlue.forEach(function (item, index) { curveBlue[index] = 0 });
	    curveGreen.forEach(function (item, index) { curveGreen[index] = 0 });
	    
	} //sampleChange
	    
	
	function guiInit(removeFolderArg) {
	    // Initializes new gui, or removes&recreates from folder removeFolderArg for updating.
	    // There may be alternatives for updating dat-gui, but this was made before knowing, e.g. so
	    //	gui.__folders['Relaxation: Off'].__controllers[1].setValue(Infinity));
	    // For details and helper functions see:
	    //   https://stackoverflow.com/questions/16166440/refresh-dat-gui-with-new-values
	    // My solution may be somewhat slow, and seems to prevent dat-gui presets from working well.
	    
	    var createFromFolder;
	    debug && console.log('guiInit called. Argument: ' + (removeFolderArg?removeFolderArg:''));
	    if (!gui) { // if new gui
		
		blochMenu = {		    
		    GetStarted: dialog("dialogGetStarted"),
		    VideoIntros: dialog("dialogVideoIntros"),
		    GetApps: dialog("dialogGetApps"),
		    Tools: dialog("dialogTools"),
		    About: dialog("dialogAbout"),
		    Reset: function () { trigSampleChange = true; }
		}
		
		state = { //dummy example values. More are added for some samples.
		    B0: 0,
		    B1: 0,
		    B1freq: 0, //angular frequency
		    phi1: 0,  //RF phase in rotating frame.
		    T1:1, T2:1,
		    Gx:0, Gy:0,
		    viewB1:false, viewTorqB1eff:true,
		    viewMxy:true, viewMx:true, viewMz:false, viewB1x:false, 
		    FrameStat: true, FrameB0: false, FrameB1: false,
		    Sample: '1 isochromate',
		    allScale: 1,
		    RFfunc: RFconst,
		    IsocArr: [],
		    t:0, tSinceRF:0, 
		};
		
		gui = new dat.GUI({autoPlace: false});
		var customContainer = $('.moveGUI').append($(gui.domElement));
		// $(gui.domElement).resizable(); //Not as intended, but has potential.
		// Initial CSS is overwritten by "new". Either move CSS
		// down or change dynamically as exemplified:
		// $('head').append(`<style>.dg li { z-index: 10; }</style>`);
		// This works, but late CSS is better. Keep example here.
		
		createFromFolder = 0;
		
	    } else { //if existing gui needing updating since folder opened/closed:
		createFromFolder = guiFolderStrs.length;
		let popped;
		do { popped = guiFolderStrs.pop();  //remove last created folders until relevant folder is reached.
		     gui.removeFolder(guiFolders.pop());
		     createFromFolder--;
		   } while ((popped != removeFolderArg) && (createFromFolder >= 0));
	    }
	    
	    var cFolder = 0;
	    
	    // All folders are attempted added, even if preexisting. However, guiAddFolder
	    // doesn't do anything until index createFromFolder is reached (indicates
	    // first folder to create, counting from cFolder).    
	    //below: Insight at https://stackoverflow.com/questions/30372761/map-dat-gui-dropdown-menu-strings-to-values
	    guiAddFolder('Bloch Simulator',
			 'Bloch Simulator',
			 function (guiFolder) {
			     guiFolder.domElement.style.fontWeight = "bold";
			     guiFolder.domElement.style.backgroundColor = "transparent";
			     let tmp=guiFolder.add(blochMenu, "GetStarted").name("Get started");
			     tmp.domElement.style.fontWeight  = "normal"; //prop exist but no 
			     // effect indep of open/close/displayUpdate/order... dat-gui bug?
			     guiFolder.add(blochMenu, "VideoIntros").name("Video intros");
			     guiFolder.add(blochMenu, "GetApps").name("Get or rate app");
			     guiFolder.add(blochMenu, "Tools").name("Related tools");
			     guiFolder.add(blochMenu, "About");
			 },
			 cFolder++, createFromFolder--);	    

	    if (addSampleFolder) {
		guiAddFolder('Sample: '+state.Sample, 
			     'Sample',
			     function (guiFolder) {
				 let tmp = state.Sample; //state.Sample is inadvertently changed by folder creation. Weirdly, the temporary saving of state cannot be moved to guiAddFolder. General problem.
				 guiFolder.add(state, 'Sample', savedFlag ? [ state.Sample] :
					       ['1 isochromate',
						'7 isochromates',
						'3 substances',
						'Line',
						'Line, dense',
						'Periodic',
						'Thermal ensemble',
						'Plane']
					      ).//listen(). //only listen() when external changes needs attention
				 onChange( function () { trigSampleChange = true; });
				 guiFolder.add(blochMenu, 'Reset');
				 state.Sample = tmp;},
			     cFolder++, createFromFolder--);
	    }
	
	    let relaxStr;
	    if ((state.T1 == Infinity) && (state.T2 == Infinity))
		relaxStr = 'Off'
	    else if (state.T1 == Infinity)
		relaxStr = 'T1 off, T2='+state.T2
	    else
		relaxStr = 'T1='+state.T1+', T2='+state.T2;	    
	    
	    guiAddFolder('Relaxation: '+relaxStr,
			 'Relaxation',
			 function (guiFolder) {
			     let tmp2 = state.T1, tmp3 = state.T2;
			     // .listen() is needed to ensure T2<T1, but disables text
			     // input without patching dat.gui: "Allows NumberSlider and
			     // Box to be edited during .listen()" (github page):
			     guiFolder.add(state, 'T1', 0, Tmax, 1).listen().onChange(
				 function () {
				     if (state.T1 == Tmax) {
					 this.updateDisplay(); //moves slider to max.
					 state.T1 = Infinity;
				     }
				     if (state.T2 > state.T1)
					 state.T2 = state.T1});
			     // .listen() is needed to ensure T1>T2. More details above.
			     guiFolder.add(state, 'T2', 0, Tmax, 1).listen().onChange(
				 function () {
				     if ((state.T1 < state.T2) && (spoilR2 == 0))
					 state.T1 = state.T2;
				     if (state.T2 == Tmax) {
					 this.updateDisplay(); //move T2 slider to max.
					 this.__gui.__controllers[0].updateDisplay(); //T1 slider also
					 state.T2 = Infinity;
					 state.T1 = Infinity;
				     }
				 });
			     state.T1 = tmp2; state.T2 = tmp3;},
			 cFolder++, createFromFolder--);
	    
	    guiViewsFolder = cFolder; // folder index is needed to update FID labels.
	    
	    let viewStr = (state.viewB1?'B1,':'') +
		((state.viewTorqB1eff && (!state.FrameB1))?'Torque,':'') +
		((state.viewTorqB1eff && (state.FrameB1))?'B1eff,':'') +
		(state.viewMx?'Mx,':'') +
		(state.viewMxy?'|Mxy|,':'') + (state.viewMz?'Mz,':'');
	    viewStr = viewStr.slice(0, -1); //chop
	    guiAddFolder('View: '+viewStr,
			 'View',
			 function (guiFolder) {
			     let tmp1 = state.viewB1, 
				 tmp2 = state.viewTorqB1eff, tmp3 = state.viewMx,
				 tmp4 = state.viewMxy, tmp5 = state.viewMz;
			     guiFolder.add(state, 'viewB1').name('B1');
			     guiFolder.add(state, 'viewTorqB1eff').
				 name('Torque / B1eff   ');
			     guiFolder.add(state, 'viewMx').name('Mx').
				 onChange( function() {
				     if (state.viewMx)
					 MxLabelIdent.show()
				     else
					 MxLabelIdent.hide()});
			     guiFolder.add(state, 'viewMxy').name('|Mxy|').
				 onChange( function() {
				     if (state.viewMxy)
					 MxyLabelIdent.show()
				     else
					 MxyLabelIdent.hide()});
			     guiFolder.add(state, 'viewMz').name('Mz').
				 onChange( function() {
				     if (state.viewMz)
					 MzLabelIdent.show()
				     else
					 MzLabelIdent.hide()});
			     state.viewB1 = tmp1; state.viewTorqB1eff = tmp2;
			     state.viewMx = tmp3; state.viewMxy = tmp4;
			     state.viewMz = tmp5;},
			 cFolder++, createFromFolder--);
	    
	    guiFieldsFolder = cFolder; // folder index is needed for updating during RF pulses.
	    guiAddFolder('Fields: B0=' + state.B0 +
			 ', B1=' + Math.round(state.B1*10)/10 +
			 ', B1freq=' + state.B1freq, //subscript doesnt work. No RF of B1 subscripts exist.
			 'Fields',
			 function (guiFolder) {
			     let tmp1 = state.B0, tmp2 = state.B1, tmp3 = state.B1freq;
			     guiFolder.add(state, 'B0', 0, B0max, 1);
			     guiFolder.add(state, 'B1', 0, 3, 0.3);
			     guiFolder.add(state, 'B1freq', 0, B0max, 0.5).//listen().
				 onChange(
				     function () { //Frame and B1 phase must be continuous.
					 if (frameFixed) {return;} //B1freq is zero then.
					 let B1freq = state.B1freq;
					 // in RFconst:
					 // B1phase = B1freq * tSinceRF - phi1 + framePhase0
					 framePhase0 += -(B1freq - lastB1freq) * state.tSinceRF;
					 lastB1freq = state.B1freq;
				     }); 
			     state.B1 = tmp1;  state.B1 = tmp2; state.B1freq = tmp3;}, 
			 cFolder++, createFromFolder--);

	    guiGradientsFolder = cFolder; // folder index needed for updating during gradient pulses.
	    guiAddFolder('Gradients: Gx=' + Math.round(state.Gx) +
			 ', Gy=' + Math.round(state.Gy),   //there is no y unicode suffix. 
			 'Gradients',
			 function (guiFolder) {
			     let tmp1 = state.Gx; let tmp2 = state.Gy; 
			     guiFolder.add(state, 'Gx', -7, 7, 1);
			     guiFolder.add(state, 'Gy', -7, 7, 1);
			     state.Gx = tmp1;  state.Gy = tmp2;},
			 cFolder++, createFromFolder--);
	    
	    let FrameStr = (state.FrameStat?'Stationary':'') + (state.FrameB0?'B0':'') +
		(state.FrameB1?'B1':'');

	    guiAddFolder('Frame: '+FrameStr,
			 'Frame',
			 function (guiFolder) {
			     let tmp1 = state.FrameStat, tmp2 = state.FrameB0, tmp3 = state.FrameB1;
			     guiFolder.add(state, 'FrameStat').name('Stationary').listen().
				 onChange(function(){state.FrameStat=true;
						     state.FrameB0=false;
						     state.FrameB1=false;
						     floor.material = floorMaterial;
						     if (floorMaterial.visible)
							 shadowMaterialsInit(floorMaterial); 
						    });
			     guiFolder.add(state, 'FrameB0').name('B0').listen().
				 onChange(function(){state.FrameStat=false;
						     state.FrameB0=true;
						     state.FrameB1=false;
						     let visible = floor.material.visible;
						     floor.material = frameFixed ?
						     floorMaterialFixed : floorMaterial;
						     if (visible)
							 shadowMaterialsInit(floor.material); 
						    });
			     guiFolder.add(state, 'FrameB1').name('B1').listen().
				 onChange(function(){state.FrameStat=false;
						     state.FrameB0=false;
						     state.FrameB1=true;
						     let visible = floor.material.visible;
						     floor.material = frameFixed ?
						     floorMaterialFixed : floorMaterial;
						     if (visible)
							 shadowMaterialsInit(floor.material);
						    });
			     state.FrameStat = tmp1;  state.FrameB0 = tmp2; state.FrameB1 = tmp3;},
			 cFolder++, createFromFolder--);
	    
	} //guiInit
		
	function shadowMaterialsInit(floorMat) {
	    
	    // BasicMaterial is fast, but doesn't respond to light like Lambert, so colors
	    // of materials don't match, even when color values do. 
	    shadowMaterials.length = 0; //clears array of shadow colors.
	    let material;
	    for(let i=0; i<nShadowColors; i++) {
		material = shadowMaterial.clone();//new THREE.MeshBasicMaterial();
		material.color.lerp( floorMat.color, i/nShadowColors*2.8); //interpolate colors.
		// Last factor extrapolates colors for large i. Maybe this (alpha-blend?)
		// slows simulation down more than Lambert material shadows would, but
		// probably not since alpha-buffer is disabled. Current solution
		// works, but may break since lerp officially requires 0..1 arg.
		// Not pursued: Floor material could alternatively be changed
		// to basic to easily match colors. 
		shadowMaterials.push(material);
	    }
	    shadowMaterials[nShadowColors-1].visible = false; //since extrapolation is not perfect.
	}
	
	function floorInit(geometry) {
	    var floorGeo;
	    switch (geometry) {
	    case 'rect': floorGeo = new THREE.PlaneBufferGeometry(10, 10); break;
	    case 'circle': floorGeo = new THREE.CircleBufferGeometry(6.5, 64); break;
	    }
	    var floor = new THREE.Mesh(floorGeo, floorMaterial);
	    floor.position.z = -1.101;
	    floor.receiveShadow = threeShadow;
	    return floor;
	} //floorInit

	function B1init() {
	    var cylMaterial = new THREE.MeshLambertMaterial({ color: "yellow" });
	    B1cyl = cylinderMesh(new THREE.Vector3(0, 0, 0),
				 new THREE.Vector3(0, 1, 0),
				 cylMaterial, 8, radius);
	    scene.add(B1cyl);
	    if (myShadow) {
		// Shadows are initialized along y to make length right subsequently.
		B1shadow = shadowMesh(new THREE.Vector3(0, 1, 0));
		scene.add(B1shadow);		
	    }
	    
	} //B1init
	
	
	function cameraInit() {
	    camera = new THREE.PerspectiveCamera(30,  window.innerWidth / window.innerHeight, 1, 10000);
	    camera.up.set( 0, 0, 1 );
	    camera.position.set (2.4, 5.6, 1.5); //probe camera.position for good coords.
	    // Viewing angle/zoom control (no keybindings except panning):
	    	controls = new THREE.OrbitControls( camera, renderer.domElement );
	    controls.enablePan = false; //avoid using arrow keys (panning).
	    controls.saveState();
	    
	    document.getElementById( 'ResetCamera' ).onclick = function () {
		controls.reset();
		document.getElementById( 'XYZview' ).innerHTML = 'XYZ';
	    }

	    document.getElementById( 'XYZview' ).onclick = function () {
		let current;
		switch (this.innerHTML) {
		case 'XYZ':
		case 'xyZ': current = 'Xyz';
		    camera.position.set(6,0,0); break;
		    //controls.target is already (0,0,0), (focus 
		    // and center of rotation), so no setting is needed.
		case 'Xyz': current = 'xYz';
		    camera.position.set (0,6,0);
		    break;
		case 'xYz': current = 'xyZ';
		    camera.position.set (0, -0.05, 6); //slightly off-axis to give shadow.
		    // Choice of off-axis is important to orient coordinate system logically.
		    // Increasing the off-axis viewing gives impression of off-center error.
		    break;		    
		}
		controls.update(); //needed whenever controls are changed manually.	
		this.innerHTML = current;
	    };
	    
	} //cameraInit
	
	function lightInit() {
	    scene.add(new THREE.AmbientLight(0x707070));            
	    var light = new THREE.DirectionalLight(0xffffff, 1);
	    light.castShadow = threeShadow;
	    light.position.set(0, 0, 100); 
	    scene.add(light);
	    scene.add( new THREE.DirectionalLightHelper(light, 0.2) );
	}	//lightInit
	
	function text3dInit() {
	    var loader = new THREE.FontLoader();
	    // Local 'file:' use requires "chrome --allow-file-access-from-files"
	    // loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {
	    loader.load( 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function ( font ) {
		var geometry = new THREE.TextBufferGeometry( 'Bloch', {
		    font: font,
		    size: 1,
		    height: 0.1,
		    curveSegments: 12,
		    bevelEnabled: true,
		    bevelThickness: 0.1,
		    bevelSize: 0.1,
		    bevelSegments: 5
		} );
		var textMesh = new THREE.Mesh(geometry, shadowMaterial);
		textMesh.rotation.x = Math.PI/2;
		textMesh.translateOnAxis(new THREE.Vector3(0,0,-1),3);
		scene.add(textMesh);
	    } );
	} //text3dInit
	
	function statsInit() {
	    statsContainer = document.createElement( 'div' );
	    document.body.appendChild( statsContainer );	      
	    stats = new Stats();
	    statsContainer.appendChild( stats.dom );
	}
	
	function rendererInit() {

	    let success = true;
	    if ( WEBGL.isWebGLAvailable() ) {
		renderer = new THREE.WebGLRenderer( {canvas: canvasA,
						     antialias:true, //smooth edges.
						     alpha:false} ); //alpha may cost performance.
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = threeShadow;
		renderer.shadowMapSoft = true;
		
	    } else {
		success = false;
		var warning = WEBGL.getWebGLErrorMessage(); 
		document.getElementById( 'WebGLmessage' ).appendChild( warning );
		dialog("dialogWebGLfail")();
		// renderer = new THREE.CanvasRenderer({ canvas: canvasA , antialias: true }); //CanvasRenderer is no longer part of THREE.
	    }

	    return success;
	} //rendererInit

	function ApplyToAll(matrix4) {
	    for (var i = 0; i < state.IsocArr.length; i++) {
		state.IsocArr[i].M.applyMatrix4(matrix4); // result is Vector3
	    }; 
	}

	function clearRepTimers() {
	    window.clearTimeout(spoilTimer1);
	    window.clearInterval(spoilTimer2);
	    window.clearInterval(spoilTimer3);
	    window.clearInterval(restartRepIfSampleChangeTimer);
	    exciteTimers.forEach(function(item) {window.clearInterval(item)});
	    exciteTimers = [];
	    restartRepIfSampleChange = false;
	}

	function exciteSpoilRepeat(TR, tipAngle, phaseCycle, spoiling, B1) {
	    clearRepTimers();
	    B1 = B1 || 4;
	    
	    let cycleLength = phaseCycle.length;	    
	    for(let i=0; i<cycleLength; i++) {
		window.setTimeout( function() {
		    RFpulse('rect', tipAngle, phaseCycle[i], B1); 
		    exciteTimers.push(setInterval( function () {
			RFpulse('rect', tipAngle, phaseCycle[i], B1)}, TR*cycleLength)); }, i*TR);
	    }

	    if (spoiling) {
		let timeBeforeSpoil = TR-spoilDuration-200
		    -300*(state.Sample == 'Plane'); //reduction need for plane, especially.
		
		spoilTimer1 = window.setTimeout(function () {spoil()}, timeBeforeSpoil);
		spoilTimer2 = window.setTimeout(function () {
		    spoilTimer3 = setInterval(function () {
			spoil()}, TR)},timeBeforeSpoil); 
	    }
	} // exciteSpoilRepeat
	
	function buttonAction(label) {

	    if (paused) {
		paused = false;
		$( "#Pause" ).button( "option", "label", "||");
		//$( "#Pause" ).button( "option", "label", "⏸");}
	    }
	    let TR;
	    switch (label) {
	    case "Precession" : state.Sample = "Precession";
		trigSampleChange = true; break;
	    case "Equilibrium" : state.Sample = "Equilibrium";
		trigSampleChange = true; break;
	    case "Inhomogeneity" : state.Sample = "Inhomogeneity";
		trigSampleChange = true; break;
	    case "Mixed matter" : state.Sample = "Mixed matter";
		trigSampleChange = true; break;
	    case "Weak gradient" : state.Sample = "Weak gradient";
		trigSampleChange = true; break;
	    case "Strong gradient" : state.Sample = "Strong gradient";
		trigSampleChange = true; break;
	    case "Structure" : state.Sample = "Structure";
		trigSampleChange = true; break;
	    case "Ensemble" : state.Sample = "Ensemble";
		trigSampleChange = true; break;
	    case "Plane" : state.Sample = "Plane";
		trigSampleChange = true; break;
//	    case "90°ʸ hard" : ApplyToAll(propagator90y); break;
	    case "90°ₓ hard" : RFpulse('rect', Math.PI/2, Math.PI, 4); break;
	    case "90°ʸ hard" : RFpulse('rect', Math.PI/2, -Math.PI/2, 4); break;
	    case "80°ₓ hard" : RFpulse('rect', Math.PI/2/9*8, Math.PI, 4); break;
	    case "30°ₓ hard" : RFpulse('rect', Math.PI/6, Math.PI, 4); break;
	    case "30°ʸ hard" : RFpulse('rect', Math.PI/6, -Math.PI/2, 4); break;
	    case "90°ₓ sinch" : RFpulse('sinc', Math.PI/2, Math.PI, 4); break;
		
	    case "90°ₓ soft" : RFpulse('rect', Math.PI/2, Math.PI, 0.3); break;
	    case "90°ʸ soft" : RFpulse('rect', Math.PI/2, -Math.PI/2, 0.3); break;
	    case "30°ₓ soft" : RFpulse('rect', Math.PI/6, Math.PI, 0.3); break;
	    case "30°ʸ soft" : RFpulse('rect', Math.PI/6, -Math.PI/2, 0.3); break;
	    case "90°ₓ sincs" : RFpulse('sinc', Math.PI/2, Math.PI, 0.8); break;
		
	    case "180°ʸ" : RFpulse('rect', Math.PI, -Math.PI/2, 8); break;
	    case "180°ₓ" : RFpulse('rect', Math.PI, Math.PI, 8); break;
	    case "160°ʸ" : RFpulse('rect', Math.PI/9*8, -Math.PI/2, 8); break;
	    case "160°ₓ" : RFpulse('rect', Math.PI/9*8, Math.PI, 8); break;
	    case "180°ʸ sincs" : RFpulse('sinc', Math.PI, -Math.PI/2, 1.6); break;

	    case "Spoil" :  $("#Presets").css('color', '#bbbbbb');
		spoil(); break; 

	    case "Gx refocus" :  $("#Presets").css('color', '#bbbbbb'); 
		if (frameFixed) gradRefocus(); break; 

	    case "Gx pulse" :  $("#Presets").css('color', '#bbbbbb'); 
		if (frameFixed) gradPulse(2); break; //whatever area
		
	    case "Gy pulse" :  $("#Presets").css('color', '#bbbbbb'); 
		if (frameFixed) gradPulse(2, Math.PI/2); break; //whatever area
		
	    case "Non-rep. exc." :
		clearRepTimers();
		break;
		
	    case "[90°ₓ] TR=5s,spoiled" :
		TR = 5000; //ms
		exciteSpoilRepeat(TR, Math.PI/2, [Math.PI], true);
		break;

	    case "[30°ʸ] TR=3s,spoiled" :
		TR = 3000; //ms
		exciteSpoilRepeat(TR, Math.PI/6, [-Math.PI/2], true);
		break;

	    case "[90°ʸ] TR=5s,spoiled" :
		TR = 5000; //ms
		exciteSpoilRepeat(TR, Math.PI/2, [-Math.PI/2], true);
		break;
		
	    case "[90°ʸ] TR=8s,spoiled" :
		TR = 8000; //ms
		exciteSpoilRepeat(TR, Math.PI/2, [-Math.PI/2], true);
		break;
		
	    case "[90°ₓ] TR=5s" :
		TR = 5000; //ms
		exciteSpoilRepeat(TR, Math.PI/2, [Math.PI], false);
		break;

	    case "[±90°ₓ] TR=5s" :
		TR = 5000; //ms
		exciteSpoilRepeat(TR, Math.PI/2, [Math.PI, 0], false);
		break;

	    case "90°ₓ-[180°ʸ]ES=5s" :
		let ES = 5000; //ms
		RFpulse('rect', Math.PI/2, Math.PI, 4); 
		window.setTimeout(
		    function() {exciteSpoilRepeat(ES, Math.PI, [-Math.PI/2],
						  false, 8);
				restartRepIfSampleChange = true; //cleared in clearRepTimers()
			       },
		    ES/2);
		restartRepIfSampleChange = true; // Restart cycle upon sample change.
		break;

	    case "||":
	    case "⏸":
	    case "\u25AE\u25AE": paused = true; $( "#Pause" ).button( "option", "label", "▶"); break;
	    case "▶" : break; // Any button restarts so corresponding action appears above.

	    case "Save" :		
		savedState = Object.assign({}, state);
		delete(savedState.IsocArr);
		savedState2 = [];
		state.IsocArr.forEach(function (item) {savedState2.push({Mx: item.M.x,
									 My: item.M.y,
									 Mz: item.M.z})});
		$( "#Presets" ).button( "option", "label", "Saved");
		savedFlag = true;  // Prevent sample changes until scene change.
		guiFolderFlags = [true, true, true, true, true, true, true, true, true]; //close all
		break;
	    case "Saved" :
		Object.assign(state, savedState); 
		state.IsocArr.forEach(function (item,index) {
		    (index >= savedState2.length) && console.log('shouldnt happen');
		    let saved = savedState2[index];
		    item.M.x = saved.Mx;
		    item.M.y = saved.My;
		    item.M.z = saved.Mz;
		});
		updateMenuList.push(2); // trigger dat-gui update of all but first folders.
		break;
	    default : alert("Button with no action pressed: "+label);
	    }
	    if (trigSampleChange) {
		if (hideWhenSelected) {
		    let menuItem = label.replace(/\s/g, ''); //no space in ids.
		    $( "#"+menuItem ).hide(); // hide menu option on button.
		}
		savedFlag = false; //restoring saved state is no longer possible.
	    }

	} // buttonAction
	
	function addConfigButton(id, leftid) {
            $("#"+id)
		.button()
		.css({'padding-left':'0em', 'padding-right':'0em'}) //width is explicit in html
                .click(function () {  //add functionality for left part
		    var label = this.textContent || this.innerText || ""; //fallbacks for limited browsersupport.
		    if ((this.id != "Presets") || (label == "Saved") || reloadSceneResetsParms) {
			buttonAction(label);
		    } else {
			trigSampleChange = true;
		    }
		})
                .next() // format right part
		.button({
                    text: false,
                    icons: {
                        primary: "ui-icon-triangle-1-s"
                    }
		})
		.click(function () { //add functionality for right part
		    let submenu = $(this).parent().next();
		    let submenuOpen = submenu.is(":visible");
		    $( ".DropDowns:visible" ).hide(); //close all submenus
		    if (!submenuOpen) //dont reopen if user is trying to close.
			submenu.show().position({
			    of: $("#"+id), //target element (reference)
			    my: "left bottom",  //placed object ref point
			    at: "left top", //target element ref point
			    collision: "none"
			});

		    $('html').one("click", function () { //hide menu if click outside of doc. Run once.
			submenu.hide();
		    });

		    
                    return false;
		})
                .parent()
		.position({of: $("#"+leftid), my: "left top", at: "right+10 top",
			   collision: "flip"}) //place right of leftid dropdown button.
                .controlgroup()  // groups the two half buttons
                .next()  // go to next node
                .hide()  //hide menu
                .menu();  //make right part a menu
            
	    $("."+id+"Action").click(function() {
		if (hideWhenSelected && (id == "Presets")) {
		    //show the hidden Presets button menu option.
		    let currButtonLabel = $("#Presets").text();
		    currButtonLabel = currButtonLabel.replace(/\s/g, ''); //no space in ids.
		    $( "#"+currButtonLabel ).show(); 
		}
		$( "#"+id ).button( "option", "label", this.innerHTML); //sets the option "label".
		buttonAction(this.textContent || this.innerText);
	    });	    
	} // addConfigButton

	function closeMenuIfOpened (id) {
	    document.getElementById( id ).onclick = function () {
		guiFolderFlags.forEach(function (item,index) {
		    (!item) && guiFolders[index].close();})}
	} // closeMenuIfOpened

	
	function addButton(id,leftid) {
	    $("#"+id)
		.button()
		.click(function () {  //add functionality for left part
		    var label = this.textContent || this.innerText || ""; //fallbacks for limited browsersupport.
		    buttonAction(label);
		})
		.parent()
		.position({of: $("#"+leftid), my: "left top", at: "right+10 top"}); //place right of leftid dropdown button.
	    
	    $("."+id+"Action").click(function() {  // adds action to buttons in the submenu.
		$( "#"+id ).button( "option", "label", $(this).text()); //sets the option "label".
	    });
	} // addButton
	
	function init() {
	    
	    scene = new THREE.Scene();
	    
	    if (myShadow) { //central dot once
		var originShadowGeo = new THREE.CircleBufferGeometry(radius, 8, 0, 2*Math.PI);
		// dot displacement error comes from z-view being off-axis for visibility.
		var originShadow = new THREE.Mesh(originShadowGeo, shadowMaterial);
		originShadow.position.z = -1.099;
		scene.add(originShadow);
	    }
	    
	    
	    doStats && statsInit();
	    magInit();
	    guiInit();
	    shadowMaterialsInit(floorMaterial);
	    floorCirc = floorInit('circle');
	    floorRect = floorInit('rect');
	    floor = floorRect;
	    scene.add(floor);
	    
	    state.Sample = "Precession";
	    trigSampleChange = true;

	    initFIDctxAxis();
	    // text3dInit(); //works. Maybe use for startup.
	    B1init();
	    lightInit();
	    if (! rendererInit()) return;
	    cameraInit();
	    addConfigButton("Presets", "leftmost"); //Add button with id "Preset" right of "leftmost"
	    addConfigButton("ExcHard","PresetsDrop"); 
	    addConfigButton("Soft","ExcHardDrop"); 
	    addConfigButton("Refocus","SoftDrop"); 
	    addConfigButton("Spoil","RefocusDrop");
	    addConfigButton("RepExc","SpoilDrop");
	    addButton("Pause", "RepExcDrop"); 
	    closeMenuIfOpened("PresetsDrop");
	    closeMenuIfOpened("ExcHardDrop");
	    closeMenuIfOpened("SoftDrop");
	    adjustToScreen();
	    window.setTimeout(0); //flush cache;	    
	    adjustToScreen(); //calling twice improves view.
	    
	    $( "#newBlochSimulator" ).dialog({
		modal: false,
		buttons: {
		    'Get help': function() {
			let guiFolder = guiFolders[0];
			guiFolder.open();
			guiFolderFlags[0] = true;
			// dialog("dialogGetStarted"); Doesnt work. Not worth trying.
			// $( "#dialogGetStarted" ).show();//dialog( "open" );
		    },
		    'Proceed': function() {
			$( this ).dialog( "close" )}
		}
	    });
	    
	    let elem = document.getElementById( 'FloorShape' );
	    let next, material;
	    elem.onclick = function () {
		scene.remove(floor);
		switch (elem.innerHTML) {
		case '⬛':  next = '◯';
		    floor.material.visible = false;
		    material = floorMaterialBlack;
		    shadowMaterialsInit(material);
		    break;
		case '⬜': next = '⬛';
		    material = floor.material; //remember material
		    material.visible = true;
		    floorRect.material = material;
		    scene.add(floor = floorRect);
		    break;
		case '◯': next = '⬜';
		    material = floor.material; //remember material
		    material.visible = true;
		    floorCirc.material = material;
		    scene.add(floor = floorCirc);
		    break;		    
		}
		shadowMaterialsInit(material);
		elem.innerHTML = next;
		
	    }

	    if (addAxisHelper) {
		var axisHelper = new THREE.AxisHelper(3 ); //length. Shows x,y,z. Works
		scene.add( axisHelper );
	    }
	    
	    document.body.appendChild(renderer.domElement);
	    
	    //	  THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) }); //Requires game extension.
	    
	} //init
	
	
	function guiUpdate() {
	    // Separate guiUpdate loop in case framerate is low:
//	    window.setTimeout(guiUpdate, 100); //ms
	    nFolder = guiFolders.length;
	    let updateFolder = updateMenuList.shift(); //Folder marked for updating? Else undefined.
	    
	    for (var cFolder = 0; //look for changes in open/closed status
		 guiFolderFlags[cFolder] == guiFolders[cFolder].closed; //As long as saved close-status matches actual.
		 cFolder++) {
		if ((updateFolder) && (updateFolder == cFolder)) {break}; // Folder marked for update?
		if (cFolder == nFolder-1) { //Check if finished. Loop terminates before if change.
		    if (trigSampleChange) {
			sampleChange(); 
			debug && console.log('guiUpdate '+state.Sample);
			guiFolderFlags = [true, true, true, true, true, true, true, true, true]; //close all
			guiInit(guiFolderStrs[1]); // Reinitialize GUI
		    };
		    return;} //nothing changed except possibly preset.
	    } 
	    // A folder change was found:
	    $("#Presets").css('color', '#bbbbbb'); //dim Scene button.
	    if (! updateFolder) //only toggle open/close if update was triggered by click.
		guiFolderFlags[cFolder] = !(guiFolderFlags[cFolder]); 
	    for (let cFolder2 = cFolder+1; cFolder2 < nFolder; cFolder2++) { //close all following open folders.
		guiFolderFlags[cFolder2] = true;
	    }
	    state.B1 = Math.round(state.B1*10)/10; // occasionally B1 ends up with many digits.
	    guiInit(guiFolderStrs[cFolder]); //Re-initialize folders following the changed one.
	} //guiUpdate

	function relaxThermal () {
	    let nIsoc = state.IsocArr.length;		
	    let rep, Mx, My, Mz, Mxy, arg, randomIsocIndi, randomIsoc, R1;
	    if (state.T1 != Infinity) {
		R1 = 1/(state.T1+0.1); //precision is not an aim here.		
		for(rep=1; rep < Math.floor(nIsoc*R1/10); rep++) { //TODO: frame rate needs to enter.
		    //repeat depending on T1 and nIsoc
		    Mz = thermalDrawFromLinearDist(state.B0); //cosTheta is linearly distributed.
		    Mxy = Math.sqrt(1 - Mz * Mz);
		    randomIsocIndi = Math.floor(nIsoc * Math.random());
		    randomIsoc = state.IsocArr[randomIsocIndi];
		    arg = Math.random() * 2 * Math.PI;
		    randomIsoc.M.fromArray([Mxy*Math.cos(arg), Mxy*Math.sin(arg), Mz]);
		}}
	    else
		R1 = 0;
	    // Additional T2 relaxation, if needed:
	    let R2 = 1/(state.T2+0.1); //precision is not an aim here.
	    if (state.T2 != Infinity) {
		for(rep=1; rep < Math.floor(nIsoc*(R2-R1)/10); rep++) { //TODO: frame rate needs to enter.
		    randomIsocIndi = Math.floor(nIsoc * Math.random());
		    randomIsoc = state.IsocArr[randomIsocIndi];
		    Mx = randomIsoc.M.x;
		    My = randomIsoc.M.y;
		    Mxy = Math.sqrt( Mx*Mx + My*My);
		    arg = Math.random() * 2 * Math.PI;
		    randomIsoc.M.x = Mxy * Math.cos(arg);
		    randomIsoc.M.y = Mxy * Math.sin(arg);
		}		
	    }
	} //relaxThermal
	
	function BlochStep(dt) {
	    state.t += dt;
	    state.tSinceRF += dt;

	    let gamma = state.Gamma;
	    let B0, B1freq;
	    
	    if ((frameFixed) && (!state.FrameStat)) { //reduce B0 and B1freq if frame is fixed.
		if (state.FrameB1) {
		    B0 = state.B0 - state.B1freq/gamma;
		    B1freq  = 0;}
		else
		    if (state.FrameB0) {
			B0 = 0;
			B1freq = state.B1freq - state.B0/gamma;
		    }}
	    else {
		B0 = state.B0;
		B1freq = state.B1freq;
	    }


	    let Gx = state.Gx;
	    let Gy = state.Gy;
	    if (state.areaLeftGrad != 0) { // is gradient refocusing ongoing?
		let angle = state.PulseGradDirection;
		let dArea = dt * gamma * (Math.cos(angle) * Gx + Math.sin(angle) * Gy);
		if (Math.abs(dArea) < Math.abs(state.areaLeftGrad)) //mid grad pulse?
		    state.areaLeftGrad -= dArea;
		else { // last time step
		    Gx *= state.areaLeftGrad / dArea * Math.cos(angle);
		    Gy *= state.areaLeftGrad / dArea * Math.sin(angle);
		    state.areaLeftGrad = 0;
		    state.Gx = 0;
		    state.Gy = 0;
		    updateMenuList.push(guiGradientsFolder); //mark gradient folder for updating
		}
	    }
	    
	    
	    let B1 = state.B1;	    
	    let B1vec, envelope;
	    if (B1 == 0) {
		B1vec = nullvec.clone(); }
	    else
		if (state.tLeftRF > 0) { // pulsing. 		    
		    // [B1vec, envelope] = state.RFfunc(B1, B1freq); //not IE compatible
		    let retval = state.RFfunc(B1, B1freq);
		    B1vec = retval[0];
		    envelope = retval[1];
		    let dArea = dt*gamma*envelope;
		    if (state.tLeftRF < dt) { //end of RF pulse
			// Adjust B1 to match tip angle on resonance (by adding delta pulse):
			B1vec.multiplyScalar(state.areaLeftRF/dArea); 
			state.areaLeftRF = 0; // end pulse
			state.tLeftRF = 0; 
			state.B1 = 0;
			updateMenuList.push(guiFieldsFolder); //mark field folder for updating
		    } else { //mid pulse
			state.areaLeftRF -= dArea;
			state.tLeftRF -= dt;
		    }
		} else { //non-pulsed RF
		    // [B1vec, envelope] = state.RFfunc(B1, B1freq); //not IE compatible
		    let retval = state.RFfunc(B1, B1freq);
		    B1vec = retval[0];
		    envelope = retval[1];
		}

	    let f1, f2, RelaxFlag, isoc;

	    if (state.Sample == 'Thermal ensemble') {
		relaxThermal();
		RelaxFlag = false;
	    } else {
		if ((state.T1 == Infinity) && (state.T2 == Infinity)) {
		    RelaxFlag = (spoilR2 != 0);
		    f1=1.; if (RelaxFlag) {f2 = Math.exp(-dt*spoilR2)};
		} else {
		    f1 = Math.exp(-dt/state.T1); f2 = Math.exp(-dt*(1./state.T2 + spoilR2));
		    RelaxFlag=true; }
	    }
	    
	    for (let Cspin=0; Cspin < state.IsocArr.length; Cspin++) {
		isoc = state.IsocArr[Cspin];
		isoc.detuning = isoc.dB0 + (Gx*isoc.pos.x + Gy*isoc.pos.y)/gradScale; 
		let Bvec = B1vec.clone().addScaledVector(unitZvec, B0 + isoc.detuning);
		isoc.detuning = (B0 + isoc.detuning)/gamma-B1freq;
		
		let Bmag = Bvec.length();
		if (Bmag != 0) {
		    isoc.M.applyAxisAngle(Bvec.divideScalar(Bmag),
					  -Bmag*dt*gamma); }

		if (! B1vec.equals(nullvec)) {
		    isoc.dMRF.crossVectors(isoc.M, B1vec).multiplyScalar(gamma);//torque
		} else
		    isoc.dMRF = nullvec.clone();
		
		if (RelaxFlag) {
		    let df2 = isoc.dR2 ? Math.exp(-isoc.dR2*dt) : 1; //extra relax for isoc
		    let df1 = (isoc.dR1  && ((state.T1*state.T2) != Infinity) && (spoilR2 == 0))?
			Math.exp(-isoc.dR1*dt) : 1;
		    let M0 = isoc.M0 ? isoc.M0 : 1;
		    isoc.M.set(isoc.M.x*f2*df2, 
			       isoc.M.y*f2*df2,
			       isoc.M.z*f1*df1 + (1.-f1*df1)*M0);
		}
		
		state.IsocArr[Cspin] = isoc; 
	    }

	    // Debugging: Check if nullvec ever changes.
	    if (debug && (! nullvec.equals(new THREE.Vector3(0., 0., 0.)))) {
		alert("nullvec changed!")}

	    return B1vec;

	} //BlochStep

	function updateFid(sample, FIDtimes, FIDvalues, color, view) {
	    if (isNaN(sample)) return;
	    FIDvalues.push(sample);
	    FIDtimes.push(state.t);
	    let FIDdurSecs = FIDduration/1000;
	    while (FIDtimes[0] < (state.t - FIDdurSecs)) {
		FIDtimes.shift(); // Don't merge with value check.
		FIDvalues.shift();
	    }
	    if (! view) {return}
	    
	    FIDctx.save();
	    FIDctx.strokeStyle = color;
	    FIDctx.lineWidth = (color == blueStr)?3:2;
	    FIDctx.translate(0, Math.floor(grHeight/2));
	    FIDctx.beginPath();
	    let len = FIDvalues.length;
	    let FidEnd = FIDtimes[len-1];
	    let downSample = Math.floor(len/200)+1; // downsample above 200 points.
	    if (downSample == 1) // no down-sampling
		FIDvalues.forEach(
		    function (item, index) { //first lineTo is interpreted as moveTo
			FIDctx.lineTo( //rounding of the values cost smoothness.
			    (1-(FidEnd-FIDtimes[index])/FIDdurSecs)*grWidth,
				-item*grHeight/2);
		    })
	    else { // Skip some line elements to save time.
		let FIDtimesDownSampled = FIDtimes.filter((e,i) => (i%downSample == 0));
		FIDvalues.filter((e,i) => (i%downSample == 0)).forEach( // keep every downSample'th
		    function (item, index) { //first lineTo is interpreted as moveTo
			FIDctx.lineTo( //rounding of the values cost smoothness.
			    (1-(FidEnd-FIDtimesDownSampled[index])/FIDdurSecs)*grWidth,
				-item*grHeight/2);
		    });
	    }
	    FIDctx.stroke();		    
	    FIDctx.restore();
	} //updateFidWrap

	
	function updateFidWrap(Mx, Mz, Mxy, color) {	    
	    switch (color) {
	    case white: 
		updateFid(Mx, MxTimes, MxCurve, 'red', state.viewMx);
		updateFid(Mz, MzTimes, MzCurve, 'gray', state.viewMz);
		updateFid(Mxy, MxyTimes, MxyCurve, 'white', state.viewMxy);
		break;
	    case green:
		updateFid(Mxy, curveGreenTimes, curveGreen, greenStr, state.viewMxy);
		break;
	    case blue:
		updateFid(Mxy, curveBlueTimes, curveBlue, blueStr, state.viewMxy);
		break;
	    default: alert("color should be specified");
	    }
	    
	} //updateFidWrap
	
	
	function animate(time) {
	    requestAnimationFrame(animate);
	    elapsed = time - then;
	    if (elapsed < fpsInterval) {return} // skip frames with long delays (loss of focus).
	    then = time - (elapsed % fpsInterval);
	    dt = (time-lastTime)/1000;
	    lastTime = time;
	    if (dt > 0.1) {return};
	    guiTimeSinceUpdate += dt;
	    if (guiTimeSinceUpdate > guiUpdateInterval) {
		guiUpdate();
		guiTimeSinceUpdate = 0;
	    }
	    
	    if (!paused) {

		// Stats on dt:
		dtTotal += dt; dtCount++;
		dtMemory[ dtMemIndi ] = dt; //short term memory of dt 
		dtMemIndi = (dtMemIndi + 1) % dtMemory.length;
		
		let B1vec = BlochStep(dt);
		let B1mag = B1vec.length(); 
		let allScale = state.allScale;

		let viewingAngle = controls.getPolarAngle(); //floor is lowered so Math.PI/2 isnt a thresh.
		let downViewRatio = 1-Math.min(viewingAngle/downViewThresh, 1); // 1..0
		let shadowMaterial = shadowMaterials[Math.round(downViewRatio * (nShadowColors-1))];
		// Clear FID
		FIDctx.clearRect(-5, -5, grWidth+10, grHeight+10); //asym borders are needed
		
		if ((B1mag != 0) && state.viewB1) { // view B1
		    B1cyl.quaternion.		    
			setFromUnitVectors(unitYvec, B1vec.clone().divideScalar(B1mag));
		    B1cyl.scale.y = B1mag*B1scale*allScale;
		    B1cyl.visible = true;
		    
		    if (myShadow) {  //shadow of B1
			var B1vecTrans = B1vec.clone().projectOnPlane(unitZvec);
			var B1vecTransLength = B1vecTrans.length();

			B1shadow.material = shadowMaterial;
			B1shadow.quaternion.
			    setFromUnitVectors(unitYvec, B1vecTrans.clone().divideScalar(B1vecTransLength));
			B1shadow.scale.y = B1vecTransLength*B1scale*allScale;  // requires length_y=1 initially.
			B1shadow.visible = true;		
		    }}
		else {
		    B1cyl.visible = false;
		    B1shadow.visible = false;
		}
		
		let Mvec, dMRFvec, torqueStart, isoc;
		let Mtot = nullvec.clone();
		let nIsoc = state.IsocArr.length;
		let showTotalCurve = true;
		for (let i = 0; i < nIsoc; i++) { 
		    isoc = state.IsocArr[i];
		    
		    Mvec = isoc.M;

		    Mtot.add(Mvec);
		    dMRFvec = isoc.dMRF; //TODO: consistent naming for vectors

		    // View effective B1 and shadow:
		    isoc.B1eff.visible = false;
		    isoc.tshadow.visible = false;
		    if ((state.FrameB1) && (state.viewTorqB1eff) && // View B1eff if B1-frame is chosen.
// Hmm, the following line was probably introduced for a good reason (maybe Ensemble), but implies that only off-resonance B1eff is shown for single isochromate if off-resonance. I'll add "|| (i==0)" as test (note that the test starts above):
//			((isoc.detuning != 0 ) || frameFixed)) { // Only show on-res B1eff when off-center isocs are present.
			((isoc.detuning != 0 ) || frameFixed || (i==0))) { // Only show on-res B1eff when off-center isocs are present.			
			let B1eff = B1vec.clone().addScaledVector(unitZvec,isoc.detuning); 
			let B1effMag = B1eff.length(); //TODO: consistent naming for magnitudes
			if (B1effMag != 0) {
			    isoc.B1eff.visible = true;
			    isoc.B1eff.quaternion.		    
				setFromUnitVectors(unitYvec, B1eff.clone().divideScalar(B1effMag));
			    isoc.B1eff.scale.y = B1effMag*B1scale*allScale;
			    isoc.B1eff.visible = true;
			    isoc.B1eff.position.set(isoc.pos.x, isoc.pos.y, isoc.pos.z);
			    
			    if (myShadow) {  //shadow of B1eff replaces torque shadow, if B1eff is shown.
				var B1effTrans = B1eff.clone().projectOnPlane(unitZvec);
				var B1effTransLength = B1effTrans.length();
				isoc.tshadow.material = shadowMaterial;
				isoc.tshadow.quaternion.
				    setFromUnitVectors(unitYvec, B1effTrans.clone().divideScalar(B1effTransLength));
				isoc.tshadow.scale.y = B1effTransLength*B1scale*allScale;  // requires length_y=1 initially.
				isoc.tshadow.visible = true; }
			    else
				isoc.tshadow.visible = false;}}
		    
		    var MvecLength = Mvec.length();
		    if (MvecLength > 0.005) { // Show magnetization
			// Sets quaternion to rotate direction vector One to direction vector Two:
			isoc.cylMesh.quaternion.		    
			    setFromUnitVectors(unitYvec, Mvec.clone().divideScalar(MvecLength));
			isoc.cylMesh.scale.y = MvecLength*allScale; // requires length_y=1 initially.
			isoc.cylMesh.position.set(isoc.pos.x, isoc.pos.y, isoc.pos.z);
			torqueStart = Mvec.clone().clampLength(0,Mvec.length()*allScale-radius/2).add(isoc.pos);
			isoc.torque.position.set(torqueStart.x, torqueStart.y, torqueStart.z);
			isoc.cylMesh.visible = true;
			isoc.shadow.visible = true;
		    } 
		    else 
			isoc.cylMesh.visible = false;
		    
		    var MvecTrans = Mvec.clone().projectOnPlane(unitZvec).multiplyScalar(allScale);
		    var MvecTransLength = MvecTrans.length();
		    if (myShadow) {  //shadow of magnetization
			if (MvecTransLength > 0.005) {

			    isoc.shadow.material = shadowMaterial;			    
			    
			    isoc.shadow.quaternion.
				setFromUnitVectors(unitYvec, MvecTrans.clone().divideScalar(MvecTransLength));
			    isoc.shadow.position.set(isoc.pos.x, isoc.pos.y, 0);
			    isoc.tshadow.position.set(isoc.pos.x, isoc.pos.y, 0); //if tshadow is used for B1eff. Else overwritten below.
			    isoc.shadow.scale.y = MvecTransLength; } // requires length_y=1 initially.
			else 
			    isoc.shadow.visible = false;
		    }
		    
		    var dMRFvecLength = dMRFvec.length();		
		    if (((dMRFvecLength < 0.01) || (! state.viewTorqB1eff)) || (state.FrameB1)) { // Show torque except in B1-frame.
			isoc.torque.visible = false;
		    }
		    else { // draw torque
			isoc.torque.visible = true;
			isoc.tshadow.visible = true;
			isoc.torque.quaternion.
			    setFromUnitVectors(unitYvec,dMRFvec.clone().divideScalar(dMRFvecLength));
			
			isoc.torque.scale.y = dMRFvecLength*torqueScale*allScale; // requires length_y=1 initially.
			
			if (myShadow) { // draw torque shadow
			    var dMRFvecTrans = dMRFvec.clone().projectOnPlane(unitZvec);
			    var dMRFvecTransLength = dMRFvecTrans.length();
			    
			    if (dMRFvecTransLength > 0.005) {
				isoc.tshadow.material = shadowMaterial;				
				isoc.tshadow.quaternion.
				    setFromUnitVectors(unitYvec, dMRFvecTrans.clone().divideScalar(dMRFvecTransLength));
				isoc.tshadow.position.set(isoc.pos.x+MvecTrans.x, isoc.pos.y+MvecTrans.y, 0);
				isoc.tshadow.scale.y = dMRFvecTransLength*torqueScale*allScale; }// requires length_y=1 initially.
			    else 
				isoc.tshadow.visible = false;}
			else 
			    isoc.tshadow.visible = false;
		    }

		    if (isoc.showCurve) { // Update Mxy curve for this isochromate.
			updateFidWrap(Mvec.x, Mvec.z, MvecTransLength, isoc.color);
			showTotalCurve = false;
		    }
		    
		} //loop over isochromates
		
		if (showTotalCurve) {
		    Mtot.multiplyScalar(state.curveScale/nIsoc);
		    updateFidWrap(Mtot.x, Mtot.z, Mtot.projectOnPlane(unitZvec).length(), white);
		}
		
		doStats && stats.update();
		
		if (! frameFixed) {
		    if (state.FrameB0) {framePhase += state.B0 * state.Gamma * dt}
		    else if (state.FrameB1) {framePhase += state.B1freq * dt};
		    scene.rotation.z = framePhase; // continuous, even if B0 or B1freq change.
		}

		
	    } //if (!pause)   
	    renderer.render(scene, camera);
	    
	    } //animate

	init();
	lastTime = window.performance.now(); //start timer
	then = lastTime;
	requestAnimationFrame(animate);
	// hideLoader();

    } //launchApp
    
    //main
    window.addEventListener('resize', onResize, false);
    window.onload = launchApp;
  </script>

    <style> /*needs to be after script since ES6 because imports overwrite */
      .moveGUI{
      position: absolute; 
      top: 0px;
      left: 0px;
      transform-origin: top left;
      transform:  scale(1.4,1.4); 
      }
      
      #textloader {
      width: 100px;
      position: absolute;
      top: calc(50% - 15px);
      left: calc(50% - 50px);
      text-align: center;
      font-size: 14px;
      }
      
      #loader {
      position: absolute;
      left: 50%;
      top: 50%;
      z-index: 50;
      width: 150px;
      height: 150px;
      margin: -75px 0 0 -75px;
      border: 16px solid #f3f3f3;
      border-radius: 50%;
      border-top: 16px solid #3498db;
      width: 120px;
      height: 120px;
      -webkit-animation: spin 2s linear infinite;
      animation: spin 2s linear infinite;
      }
      
      @@-webkit-keyframes spin {
      0% { -webkit-transform: rotate(0deg); }
      100% { -webkit-transform: rotate(360deg); }
      }
      
      @@keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
      }
      
      /* Event buttons and their submenus are on top: */
      .EventButtons { z-index: 20; }
      li { z-index: 20; font-size: 130%;}
      
      /* props of datgui menu items: */
      .dg li.title { background-color: transparent; border-bottom: none;
      text-shadow:
      0.25px 0.25px 0.5px black,
      0.25px -0.25px 0.5px black,
      -0.25px 0.25px 0.5px black,
      -0.25px -0.25px 0.5px black;}
      
      .dg li.save-row { background-color: transparent; border-bottom: none; transform: scale(0.75,0.75) translate(-35px,5px);}

      .dg .property-name { white-space: nowrap; text-overflow: clip;}
      
      .dg.main .close-button { display: none; }
      
      #guiSetting { 
      transform: scale(1.5,1.5) translate(15%,0%);
      position: relative;
      }
      
      #gui_container{ 
      position: absolute;
      top: 10%;
      left: 0%;
      z-index: 10;
      }

      html,body {
      margin:2px;
      font-family:"Trebuchet MS", "Helvetica", "Arial", "Verdana", "sans-serif";
      font-size: 100%;
      /* Avoid text highlighting (inadvertent cut/paste): */
      -webkit-user-select: none; 
      -webkit-touch-callout: none; 
      -moz-user-select: none; 
      -ms-user-select: none; 
      user-select: none;    
      }
      
      
      .dialog a {color: darkred;}
      
      
      .ui-menu { max-width: 190px; white-space: nowrap; }/* split button menu */
      
      
      .ui-button {
      padding-left: 0em;
      padding-right: 0em;}
      
    </style>
    
  <div id="WebGLmessage" style="transform: scale(1.3,1.3) translate(0px,0px);">
  </div> 


<div  class="moveGUI">
</div>
  
  <!-- Add display:none below when developing to avoid 3D rendering. -->
  <canvas id="canvasA" width="100%" height="100%"
	  style="position: absolute; left: 0px; top: 0px; z-index: -3">
  </canvas>
  
<div id="fidbox" style="height:245px; width:245px; padding:0 0 0 0; border: 0 0 0 0;  background-color:transparent; position:absolute; top:1%; right:1%;">
  <canvas id="FIDcanvasAxis" style="position: absolute; z-index: 39; height:100%; width:100%;"> 
  </canvas>
  <canvas id="FIDcanvas" style="position: absolute; z-index: 40; height:100%; width:100%">
  </canvas>
  <div id="MxyLabel" style="position: absolute; right: 10px; top: 7px; z-index: 20;font-family: Arial, Helvetica, Geneva, sans-serif; color: white">|Mxy|</div>
  <div id="MxLabel" style="position: absolute; right: 10px; top: 24px; z-index: 20;font-family: Arial, Helvetica, Geneva, sans-serif; color: red">Mx</div>
  <div id="MzLabel" style="position: absolute; right: 10px; top: 41px; z-index: 20;font-family: Arial, Helvetica, Geneva, sans-serif; color: gray">Mz</div>
</div>


<!-- Event menu begins -->
<div id="EventMenu" style="zoom:0.3; display:inline-block; max-width:1000px">
  <!-- Setting zoom small ensures sufficient space at initial rendering. -->
  
    <div id="leftmost" style="position:absolute; width:0%; bottom:3%"> </div>
    
    <div class="EventButtons" style="position:absolute; bottom:3%"> 
      <button id="Presets" style="width:8em; height:2em; background-color:#842326; color:#bbbbbb">Equilibrium</button>
      <button id="PresetsDrop" style="height:2em">select scene</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns" style="z-index: 30">
      <!-- <li><a class="PresetsAction">Precession</a></li> --> <!-- class name must be "buttonid+Action" -->
      <li id="Equilibrium" ><a class="PresetsAction">Equilibrium</a></li> <!--style="display:none-->
      <!-- Equilibrium menu item needs to be hidden if hideWhenSelected is true since
	   that label is shown on button above. Otherwise comment hiding out. --> 
      <li id="Inhomogeneity"><a class="PresetsAction">Inhomogeneity</a></li>
      <li id="Mixedmatter"><a class="PresetsAction">Mixed matter</a></li>
      <li id="Weakgradient"><a class="PresetsAction">Weak gradient</a></li>
      <li id="Stronggradient"><a class="PresetsAction">Strong gradient</a></li>
      <li id="Structure"><a class="PresetsAction">Structure</a></li>
      <li id="Ensemble"><a class="PresetsAction">Ensemble</a></li>
      <li id="Plane"><a class="PresetsAction">Plane</a></li>      
      <li id="Saving"> <a class="PresetsAction">Save</a></li> 
    </ul>

    <div class="EventButtons" style="position:absolute; bottom:3%"> 
      <button id="ExcHard" style="width:5.5em; height:2em">90°<i style='position: relative; left: -.4em;'>ₓ</i> hard</button>  <!-- Unicode latin subscript small letter x (U+2093) (not UTF-8)-->
      <button id="ExcHardDrop" style="height:2em">excite hard</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns">
      <li><a class="ExcHardAction">90°<i style='position: relative; left: -.4em;'>ₓ</i> hard</a></li>  <!-- class name must be "buttonid+Action" -->
      <li><a class="ExcHardAction">90°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i> hard</a></li>
      <li><a class="ExcHardAction">80°<i style='position: relative; left: -.4em;'>ₓ</i> hard</a></li>
      <li><a class="ExcHardAction">30°<i style='position: relative; left: -.4em;'>ₓ</i> hard</a></li>
<!--      <li><a class="ExcHardAction">30°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i> hard</a></li>-->
      <li><a class="ExcHardAction">90°<i style='position: relative; left: -.4em;'>ₓ</i> sinc<i style='position: relative; top: 0.3em;font-size:0.6em;'>h</i></a></li>
    </ul>

    <div class="EventButtons" style="position:absolute; bottom:3%"> 
      <button id="Soft" style="width:5em; height:2em">90°<i style='position: relative; left: -.4em;'>ₓ</i> soft</button>
      <button id="SoftDrop" style="height:2em">selective pulsing</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns">
      <li><a class="SoftAction">90°<i style='position: relative; left: -.4em;'>ₓ</i> soft</a></li> <!-- class name must be "buttonid+Action" -->
      <li><a class="SoftAction">90°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i> soft</a></li>
      <li><a class="SoftAction">30°<i style='position: relative; left: -.4em;'>ₓ</i> soft</a></li>
      <li><a class="SoftAction">30°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i> soft</a></li>
      <li><a class="SoftAction">90°<i style='position: relative; left: -.4em;'>ₓ</i> sinc<i style='position: relative; top: 0.3em;font-size:0.6em;'>s</i></a></li>
      <li><a class="SoftAction">180°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i> sinc<i style='position: relative; top: 0.3em;font-size:0.6em;'>s</i></a></li>
    </ul>
    
    <div class="EventButtons" style="position:absolute; bottom:3%">
      <button id="Refocus" style="width:3.5em; height:2em">180°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i></button>
      <button id="RefocusDrop" style="height:2em">refocusing</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns">
      <li><a class="RefocusAction">180°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i></a></li> <!-- class name must be "buttonid+Action" -->
      <li><a class="RefocusAction">180°<i style='position: relative; left: -.4em;'>ₓ</i></a></li>
      <li><a class="RefocusAction">160°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i></a></li>
      <li><a class="RefocusAction">160°<i style='position: relative; left: -.4em;'>ₓ</i></a></li>
    </ul>
    
    <div class="EventButtons" style="position:absolute; bottom:3%">
      <button id="Spoil" style="width:6em; height:2em">Spoil</button>
      <button id="SpoilDrop" style="height:2em">gradient pulses</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns">
      <li><a class="SpoilAction">Spoil</a></li> 
      <li><a class="SpoilAction">Gx refocus</a></li>
      <li><a class="SpoilAction">Gx pulse</a></li>
      <li><a class="SpoilAction">Gy pulse</a></li> 
    </ul>
    
    <div class="EventButtons" style="position:absolute; bottom:3%">
      <button id="RepExc" style="width:8em; height:2em">Non-rep. exc.</button>
      <button id="RepExcDrop" style="height:2em">repeated exc.</button> <!-- text is tool tip -->
    </div>
    <ul class="DropDowns"> 
      <li><a class="RepExcAction">Non-rep. exc.</a></li> 
      <li><a class="RepExcAction">[90°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=5s,spoiled</i></a></li>
      <li><a class="RepExcAction">[90°<i style='position: relative; left: -.4em;'>ₓ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=5s,spoiled</i></a></li>
      <li><a class="RepExcAction">[90°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=8s,spoiled</i></a></li>
      <li><a class="RepExcAction">[30°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=3s,spoiled</i></a></li>
      <li><a class="RepExcAction">[90°<i style='position: relative; left: -.4em;'>ₓ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=5s</i></a></li>
      <li><a class="RepExcAction">[±90°<i style='position: relative; left: -.4em;'>ₓ</i>] <i style='position: relative; left: -.4em; top: 0.3em;font-size:0.6em;'>TR=5s</i></a></li>
      <li><a class="RepExcAction">90°<i style='position: relative; left: -.4em;'>ₓ</i>-[180°<i style='position: relative; left: -.4em; top: 0.3em;'>ʸ</i>]<i style='position: relative; left: -.0em; top: 0.3em;font-size:0.6em;'>ES=5s</i></a></li>
    </ul>
    
    <div class="EventButtons" style="position:absolute; bottom:3%">
      <button id="Pause" style="height:2em;width:2.5em;font-weight:bold">||<!--&#9646;&#9646;--></button> <!-- ⏸ -->
    </div>
</div> <!-- Event menu ends -->
  
  
<div id="icons" class="icons" style="text-shadow: 1px 1px 2px white; position:absolute; bottom:10%; right:1%; width:20px"> 
  <div id="FloorShape">◯</div><br>
  <div id="XYZview">XYZ</div><br>
  <div id="ResetCamera" style="font-size:150%;">⏎</div><br>
</div>


<div id="dialogGetStarted" class="dialog" title="Getting started" style="display: none;">
  <p>
    Click and drag to navigate around the shown spin system.

    The red configurable button (left) offers a selection of starting
    points for MR experiments (incl. samples). The neighboring buttons
    trigger a wide variety of events such as RF and gradient pulses.
    
    The left menu is used to set field, viewing and relaxation properties.
    
    The icons to the right offer more viewing options, e.g. specific viewing angles.
  </p>
</div>

<div id="dialogVideoIntros" class="dialog" title="Video Introductions" style="display: none;">
  <p>
    <a onClick='window.open("https://www.youtube.com/watch?v=6aWBZtypU7w&list=PL23477A8FD874A872", "_system")'>
      Video introductions</a> to the Bloch Simulator are available
    from YouTube™. Currently these demonstrate the older
    Flash™/ActionScript™-based version that is still available at the
    main <a onClick='window.open("http://drcmr.dk/bloch", "_system")'>software homepage</a>.
    The new version is somewhat similar but much functionality was added.
  </p>
</div>

<div id="dialogGetApps" class="dialog" title="Get or rate app" style="display: none;">
  <p>
    The Bloch Simulator is available as a free app for Android™ devices via
    <a onClick='window.open("https://play.google.com/store/apps/developer?id=Lars+G.+Hanson", "_system")'>
    Google Play™</a> and Huawei AppGallery™. The app improves the user
    experience considerably over the web page for small devices. Similar
    apps for iOS™ and possibly other platforms will soon follow (ask).
  </p>  
  <p>Feedback is appreciated. Please <a onClick='window.open("https://play.google.com/store/apps/developer?id=Lars+G.+Hanson", "_system")'>rate and comment</a> in the appropriate app store. 
  </p>
</div>

<div id="dialogTools" class="dialog" title="Related tools" style="display: none;">
  <p>
    Other educational NMR/MRI tools by <a onClick='window.open("http://drcmr.dk/larsh", "_system")'>Lars G. Hanson</a>:</p> <!-- terrible list look-alike. Note: Bullet height needs adjustment -->
  <p><span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 40px 0;"></span>
    The <a onClick='window.open("http://www.drcmr.dk/CompassMR", "_system")'>CompassMR Simulator</a>
    and Android™
    <a onClick='window.open("https://play.google.com/store/apps/details?id=dk.drcmr.compassmr",
       "_system")'>app</a>
    giving insight into basic MR</p>
  
  <p><span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 20px 0;"></span>
    <a onClick='window.open("http://www.drcmr.dk/fid", "_system")'>
      Interactive FID and Spectrum Explorers</a></p>
  
  <p><span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 20px 0;"></span>
    <a onClick='window.open("http://www.drcmr.dk/MR", "_system")'>Lots of other material</a>
    (notes, animations, explanations,...) </p>
</div>

<div id="dialogAbout" class="dialog" title="About" style="display: none;">
  <p>
    The <b>Bloch Simulator</b> (here version 1.0.9) was created by
    <a onClick='window.open("http://drcmr.dk/larsh", "_system")'>Lars G. Hanson</a>
    (<a onClick='window.open("http://cmr.healthtech.dtu.dk", "_system")'>DTU</a>,
    <a onClick='window.open("http://www.drcmr.dk/larsh", "_system")'>DRCMR</a>)
    to aid challenging MRI and NMR education. You can interactively perform
    Magnetic Resonance measurements in almost any browser.
    The app is currently only for Android™ though.</p>
  <p>
    Your feedback is most welcome, but support
    limited for this open-sourced hobby project (channels:
    <a onClick='window.open("https://play.google.com/store/apps/developer?id=Lars+G.+Hanson",
       "_system")'>app store</a>,
    <a onClick='window.open("https://www.youtube.com/user/larsghanson/videos?app=desktop",
       "_system")'>YouTube™</a>,
    <a onClick='window.open("https://dk.linkedin.com/in/larshanson", "_system")'>LinkedIn™</a>,
    <a onClick='window.open("https://github.com/larsh957/Bloch-Simulator",
       "_system")'>GitHub™</a>,
    fist bumps at conferences,
    <a onClick='window.open("mailto:larsh"+"@drcmr.dk", "_system")'>e-mail</a>). Click for main
    <a onClick='window.open("http://drcmr.dk/bloch", "_system")'>software homepage</a>.
  </p>
</div>

<div id="dialogUseLandscape" class="dialog" title="Use landscape mode" style="display:none;">
  <p>
    The <b>Bloch Simulator</b> is designed for landscape screen mode only, and will
    likely look horrible unless your device is rotated.
  </p>
</div>

<div id="dialogConsiderApp" class="dialog" title="Consider using app" style="display:none;z-index: 100">
  <p>
    On small devices, the corresponding app will give you a better experience due
    to improved screen usage.
    <a onClick='window.open("https://play.google.com/store/apps/developer?id=Lars+G.+Hanson",
       "_system")'>Click for Android app info</a>.
  </p>
</div>

<div id="dialogWebGLfail" class="dialog" title="WebGL error" style="display:none;">
  <p>
    The Bloch Simulator requires the browser functionality WebGL to work (graphics
    accelleration). Advice for checking and enabling it is here:<br>
    <a onClick='window.open("https://get.webgl.org", "_system")'>https://get.webgl.org</a>
  </p>
</div>

<div id="newBlochSimulator" class="dialog" title="New Bloch Simulator" style="display:none;">
  <p>This is the  
    <a onClick='window.open("http://drcmr.dk/bloch","_system")'>Bloch Simulator</a>
    offering interactive exploration of Magnetic Resonance and a wide range of 
    MRI and NMR techniques. This version replaces the
    <a onClick='window.open("http://drcmr.dk/BlochSimulator/index.Flash.html",
       "_system")'>older Flash™ version</a>. The corresponding
    <a onClick='window.open("https://play.google.com/store/apps/developer?id=Lars+G.+Hanson",
       "_system")'>Android™ app</a> improves the experience on small devices.
    Reduce window size for smoother animations. Please report errors.</p>

    <p>The top-left menu item will help you get started. Enjoy!</p>
</div>

<!-- SocialMedia goes here. -->

<!-- Analytics goes here. -->

<!-- Loader: Enable hideLoader call in launchApp also --> <!--
<div id="textloader">Loading Bloch Simulator...</div>
<div id="loader"></div>
<script language="javascript" type="text/javascript">
    function hideLoader() {
	document.getElementById("loader").style.display = "none";
	document.getElementById("textloader").style.display = "none";
    }
</script>
-->

</body>
</html>
